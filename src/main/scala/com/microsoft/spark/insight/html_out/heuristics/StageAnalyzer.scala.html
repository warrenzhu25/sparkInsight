<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>heuristics/StageAnalyzer.scala - Spark Insight</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}


  </style>
 </head>
 <body>

  <h1>heuristics/StageAnalyzer.scala - Spark Insight</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L78">ExecutionMemorySpillResult</a></li>
<li><a href="#L43">SimpleStageAnalysisResult</a></li>
<li><a href="#L28">StageAnalysis</a></li>
<li><a href="#L31">StageAnalysisResult</a></li>
<li><a href="#L125">StagesAnalyzer</a></li>
<li><a href="#L98">TaskFailureResult</a></li>
<li><a href="#L58">TaskSkewResult</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L222">checkForExecutionMemorySpill</a></li>
<li><a href="#L587">checkForGC</a></li>
<li><a href="#L385">checkForLongTasks</a></li>
<li><a href="#L553">checkForSpecificTaskError</a></li>
<li><a href="#L441">checkForStageFailure</a></li>
<li><a href="#L464">checkForTaskFailure</a></li>
<li><a href="#L283">checkForTaskSkew</a></li>
<li><a href="#L360">checkSkewedData</a></li>
<li><a href="#L39">format</a></li>
<li><a href="#L453">format</a></li>
<li><a href="#L519">getMessage</a></li>
<li><a href="#L576">getNumTasksWithError</a></li>
<li><a href="#L183">getStageAnalysis</a></li>
<li><a href="#L529">getTargetHost</a></li>
<li><a href="#L498">groupByHost</a></li>
<li><a href="#L488">groupByMessage</a></li>
<li><a href="#L507">groupByTargetHost</a></li>
<li><a href="#L431">hasSignificantSeverity</a></li>
</ul>
 <h2>Source code</h2>

  <code>/*<br/>
 * Licensed to the Apache Software Foundation (ASF) under one or more<br/>
 * contributor license agreements.&nbsp; See the NOTICE file distributed with<br/>
 * this work for additional information regarding copyright ownership.<br/>
 * The ASF licenses this file to You under the Apache License, Version 2.0<br/>
 * (the &quot;License&quot;); you may not use this file except in compliance with<br/>
 * the License.&nbsp; You may obtain a copy of the License at<br/>
 *<br/>
 *&nbsp; &nbsp; http://www.apache.org/licenses/LICENSE-2.0<br/>
 *<br/>
 * Unless required by applicable law or agreed to in writing, software<br/>
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,<br/>
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<br/>
 * See the License for the specific language governing permissions and<br/>
 * limitations under the License.<br/>
 */<br/>
package com.microsoft.spark.insight.heuristics<br/>
<br/>
import com.microsoft.spark.insight.fetcher.<a href="../fetcher/SparkApplicationData.scala.html#L21" title="fetcher/SparkApplicationData.scala:21">SparkApplicationData</a><br/>
import com.microsoft.spark.insight.fetcher.<a href="../fetcher/status/statusapiv1.scala.html#L111" title="fetcher/status/statusapiv1.scala:111">status</a>._<br/>
import com.microsoft.spark.insight.util.{MemoryFormatUtils, Utils}<br/>
<br/>
import scala.collection.mutable.ArrayBuffer<br/>
<br/>
/**<br/>
 * Analysis results for a <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a>.<br/>
 */<br/>
<a id="L28">&#x200c;</a>case class <span class="linkable">StageAnalysis</span>(stageData: <a href="../fetcher/status/statusapiv1.scala.html#L148" title="fetcher/status/statusapiv1.scala:148">StageData</a>,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stageAnalysisResults: Seq[<a href="#L31" title="heuristics/StageAnalyzer.scala:31">StageAnalysisResult</a>])<br/>
<br/>
<a id="L31">&#x200c;</a>trait <span class="linkable">StageAnalysisResult</span> extends <a href="HeuristicResult.scala.html#L18" title="heuristics/HeuristicResult.scala:18">AnalysisResult</a> {<br/>
<br/>
&nbsp; val stageData: <a href="../fetcher/status/statusapiv1.scala.html#L148" title="fetcher/status/statusapiv1.scala:148">StageData</a><br/>
<br/>
&nbsp; val <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a>: Seq[String]<br/>
<br/>
&nbsp; val <a href="../fetcher/status/statusapiv1.scala.html#L48" title="fetcher/status/statusapiv1.scala:48">name</a>: String<br/>
<br/>
<a id="L39">&#x200c;</a>&nbsp; def <span class="linkable">format</span>(stageData: <a href="../fetcher/status/statusapiv1.scala.html#L148" title="fetcher/status/statusapiv1.scala:148">StageData</a>): String =<br/>
&nbsp; &nbsp; s&quot;Stage ${stageData.<a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a>} (Attempt ${stageData.<a href="../fetcher/status/statusapiv1.scala.html#L59" title="fetcher/status/statusapiv1.scala:59">attemptId</a>}) : ${stageData.<a href="../fetcher/status/statusapiv1.scala.html#L48" title="fetcher/status/statusapiv1.scala:48">name</a>}&quot;<br/>
}<br/>
<br/>
<a id="L43">&#x200c;</a>case class <span class="linkable">SimpleStageAnalysisResult</span>(<a href="../fetcher/status/statusapiv1.scala.html#L48" title="fetcher/status/statusapiv1.scala:48">name</a>: String,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stageData: <a href="../fetcher/status/statusapiv1.scala.html#L148" title="fetcher/status/statusapiv1.scala:148">StageData</a>,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a>: Seq[String]) extends <a href="#L31" title="heuristics/StageAnalyzer.scala:31">StageAnalysisResult</a>{<br/>
&nbsp; override def toString: String = {<br/>
&nbsp; &nbsp; s&quot;&quot;&quot;<br/>
&nbsp; &nbsp; &nbsp;&nbsp; |${<a href="#L39" title="heuristics/StageAnalyzer.scala:39">format</a>(stageData)} $<a href="../fetcher/status/statusapiv1.scala.html#L48" title="fetcher/status/statusapiv1.scala:48">name</a> Result<br/>
&nbsp; &nbsp; &nbsp;&nbsp; |======================<br/>
&nbsp; &nbsp; &nbsp;&nbsp; |${<a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a>.mkString(&quot;\<a href="../utils/AggregatePerfValue.scala.html#L28" title="utils/AggregatePerfValue.scala:28">n</a>&quot;)}<br/>
&nbsp; &nbsp; &nbsp;&nbsp; |&quot;&quot;&quot;.stripMargin<br/>
&nbsp; }<br/>
}<br/>
<br/>
/**<br/>
 * Stage analysis result for examining the <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a> for task skew.<br/>
 */<br/>
<a id="L58">&#x200c;</a>private case class <span class="linkable">TaskSkewResult</span>(stageData: <a href="../fetcher/status/statusapiv1.scala.html#L148" title="fetcher/status/statusapiv1.scala:148">StageData</a>,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a>: Seq[String]) extends <a href="#L31" title="heuristics/StageAnalyzer.scala:31">StageAnalysisResult</a> {<br/>
&nbsp; val <a href="../fetcher/status/statusapiv1.scala.html#L48" title="fetcher/status/statusapiv1.scala:48">name</a> = &quot;Task Skew&quot;<br/>
<br/>
&nbsp; override def toString: String = {<br/>
&nbsp; &nbsp; s&quot;&quot;&quot;<br/>
&nbsp; &nbsp; &nbsp;&nbsp; |${<a href="#L39" title="heuristics/StageAnalyzer.scala:39">format</a>(stageData)} $<a href="../fetcher/status/statusapiv1.scala.html#L48" title="fetcher/status/statusapiv1.scala:48">name</a> Result<br/>
&nbsp; &nbsp; &nbsp;&nbsp; |======================<br/>
&nbsp; &nbsp; &nbsp;&nbsp; |${<a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a>.mkString(&quot;\<a href="../utils/AggregatePerfValue.scala.html#L28" title="utils/AggregatePerfValue.scala:28">n</a>&quot;)}<br/>
&nbsp; &nbsp; &nbsp;&nbsp; |&quot;&quot;&quot;.stripMargin<br/>
&nbsp; }<br/>
}<br/>
<br/>
/**<br/>
 * Stage analysis result for examining the <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a> for execution memory spill.<br/>
 *<br/>
 * @param <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; information and recommendations from analysis for execution memory spill.<br/>
 * @param <a href="../fetcher/status/statusapiv1.scala.html#L74" title="fetcher/status/statusapiv1.scala:74">memoryBytesSpilled</a>&nbsp; the total amount of execution memory bytes spilled for the <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a>.<br/>
 * @param maxTaskBytesSpilled the maximum number of bytes spilled by a task.<br/>
 */<br/>
<a id="L78">&#x200c;</a>case class <span class="linkable">ExecutionMemorySpillResult</span>(stageData: <a href="../fetcher/status/statusapiv1.scala.html#L148" title="fetcher/status/statusapiv1.scala:148">StageData</a>,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a>: Seq[String],<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L74" title="fetcher/status/statusapiv1.scala:74">memoryBytesSpilled</a>: Long,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxTaskBytesSpilled: Long) extends <a href="#L31" title="heuristics/StageAnalyzer.scala:31">StageAnalysisResult</a> {<br/>
&nbsp; val <a href="../fetcher/status/statusapiv1.scala.html#L48" title="fetcher/status/statusapiv1.scala:48">name</a> = &quot;Spill&quot;<br/>
<br/>
&nbsp; override def toString: String = {<br/>
&nbsp; &nbsp; s&quot;&quot;&quot;<br/>
&nbsp; &nbsp; &nbsp;&nbsp; |${<a href="#L39" title="heuristics/StageAnalyzer.scala:39">format</a>(stageData)} $<a href="../fetcher/status/statusapiv1.scala.html#L48" title="fetcher/status/statusapiv1.scala:48">name</a> Result<br/>
&nbsp; &nbsp; &nbsp;&nbsp; |======================<br/>
&nbsp; &nbsp; &nbsp;&nbsp; |${<a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a>.mkString(&quot;\<a href="../utils/AggregatePerfValue.scala.html#L28" title="utils/AggregatePerfValue.scala:28">n</a>&quot;)}<br/>
&nbsp; &nbsp; &nbsp;&nbsp; |&quot;&quot;&quot;.stripMargin<br/>
&nbsp; }<br/>
}<br/>
<br/>
/**<br/>
 * Stage analysis result for examining the <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a> for task failures.<br/>
 *<br/>
 * @param <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; information and recommendations from analysis for task failures.<br/>
 */<br/>
<a id="L98">&#x200c;</a>case class <span class="linkable">TaskFailureResult</span>(stageData: <a href="../fetcher/status/statusapiv1.scala.html#L148" title="fetcher/status/statusapiv1.scala:148">StageData</a>,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a>: Seq[String],<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L488" title="heuristics/StageAnalyzer.scala:488">groupByMessage</a>: Map[String, Int],<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; groupByTarget: Map[String, Int]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ) extends <a href="#L31" title="heuristics/StageAnalyzer.scala:31">StageAnalysisResult</a> {<br/>
&nbsp; val <a href="../fetcher/status/statusapiv1.scala.html#L48" title="fetcher/status/statusapiv1.scala:48">name</a> = &quot;Failure&quot;<br/>
<br/>
&nbsp; override def toString: String = {<br/>
&nbsp; &nbsp; s&quot;&quot;&quot;<br/>
&nbsp; &nbsp; &nbsp;&nbsp; |${<a href="#L39" title="heuristics/StageAnalyzer.scala:39">format</a>(stageData)} $<a href="../fetcher/status/statusapiv1.scala.html#L48" title="fetcher/status/statusapiv1.scala:48">name</a> Result<br/>
&nbsp; &nbsp; &nbsp;&nbsp; |======================<br/>
&nbsp; &nbsp; &nbsp;&nbsp; |${<a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a>.mkString(&quot;\<a href="../utils/AggregatePerfValue.scala.html#L28" title="utils/AggregatePerfValue.scala:28">n</a>&quot;)}<br/>
&nbsp; &nbsp; &nbsp;&nbsp; |Stage Task Failure group by error message<br/>
&nbsp; &nbsp; &nbsp;&nbsp; |======================<br/>
&nbsp; &nbsp; &nbsp;&nbsp; |${<a href="#L488" title="heuristics/StageAnalyzer.scala:488">groupByMessage</a>.mkString(&quot;\<a href="../utils/AggregatePerfValue.scala.html#L28" title="utils/AggregatePerfValue.scala:28">n</a>&quot;)}<br/>
&nbsp; &nbsp; &nbsp;&nbsp; |Stage Task Failure group by target <a href="../fetcher/status/statusapiv1.scala.html#L196" title="fetcher/status/statusapiv1.scala:196">host</a><br/>
&nbsp; &nbsp; &nbsp;&nbsp; |======================<br/>
&nbsp; &nbsp; &nbsp;&nbsp; |${groupByTarget.mkString(&quot;\<a href="../utils/AggregatePerfValue.scala.html#L28" title="utils/AggregatePerfValue.scala:28">n</a>&quot;)}<br/>
&nbsp; &nbsp; &nbsp;&nbsp; |&quot;&quot;&quot;.stripMargin<br/>
&nbsp; }<br/>
}<br/>
<br/>
/**<br/>
 * Analyzes the <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a> level metrics for the given application.<br/>
 *<br/>
 * @param data Spark application data<br/>
 */<br/>
<a id="L125">&#x200c;</a>private[heuristics] class <span class="linkable">StagesAnalyzer</span>(private val data: <a href="../fetcher/SparkApplicationData.scala.html#L21" title="fetcher/SparkApplicationData.scala:21">SparkApplicationData</a>) {<br/>
<br/>
&nbsp; import <a href="ConfigUtils.scala.html#L20" title="heuristics/ConfigUtils.scala:20">ConfigUtils</a>._<br/>
<br/>
&nbsp; // serverity thresholds for execution memory spill<br/>
&nbsp; private val executionMemorySpillThresholds: <a href="SeverityThresholds.scala.html#L22" title="heuristics/SeverityThresholds.scala:22">SeverityThresholds</a> =<br/>
&nbsp; &nbsp; DEFAULT_EXECUTION_MEMORY_SPILL_THRESHOLDS<br/>
<br/>
&nbsp; // severity thresholds for task skew<br/>
&nbsp; private val taskSkewThresholds = DEFAULT_TASK_SKEW_THRESHOLDS<br/>
<br/>
&nbsp; // severity thresholds for task duration (long running <a href="../fetcher/status/statusapiv1.scala.html#L180" title="fetcher/status/statusapiv1.scala:180">tasks</a>)<br/>
&nbsp; private val taskDurationThresholds = DEFAULT_TASK_DURATION_THRESHOLDS<br/>
<br/>
&nbsp; // severity thresholds for task failures<br/>
&nbsp; private val taskFailureRateSeverityThresholds = DEFAULT_TASK_FAILURE_RATE_SEVERITY_THRESHOLDS<br/>
<br/>
&nbsp; // execution memory spill: threshold for processed data, above which some spill is expected<br/>
&nbsp; private val maxDataProcessedThreshold = MemoryFormatUtils.stringToBytes(DEFAULT_MAX_DATA_PROCESSED_THRESHOLD)<br/>
<br/>
&nbsp; // threshold for ratio of <a href="../utils/AggregatePerfValue.scala.html#L26" title="utils/AggregatePerfValue.scala:26">max</a> task duration to <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a> duration, for flagging task skew<br/>
&nbsp; private val longTaskToStageDurationRatio = DEFAULT_LONG_TASK_TO_STAGE_DURATION_RATIO.toDouble<br/>
<br/>
&nbsp; // <a href="../utils/AggregatePerfValue.scala.html#L24" title="utils/AggregatePerfValue.scala:24">min</a> threshold for median task duration, for flagging task skew<br/>
&nbsp; private val taskDurationMinThreshold = DEFAULT_TASK_SKEW_TASK_DURATION_MIN_THRESHOLD.toLong<br/>
<br/>
&nbsp; // the maximum number of recommended <a href="../fetcher/status/statusapiv1.scala.html#L133" title="fetcher/status/statusapiv1.scala:133">partitions</a><br/>
&nbsp; private val maxRecommendedPartitions = DEFAULT_MAX_RECOMMENDED_PARTITIONS.toInt<br/>
<br/>
&nbsp; // recommendation to give if there is execution memory spill due to too much data being processed.<br/>
&nbsp; // Some amount of spill is expected in this, but alert the users so that they are aware that spill<br/>
&nbsp; // is happening.<br/>
&nbsp; private val executionMemorySpillRecommendation = DEFAULT_EXECUTION_MEMORY_SPILL_LARGE_DATA_RECOMMENDATION<br/>
<br/>
&nbsp; // recommendation to give if task skew is detected, and input data is read for the <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a>.<br/>
&nbsp; private val taskSkewInputDataRecommendation = DEFAULT_TASK_SKEW_INPUT_DATA_RECOMMENDATION<br/>
<br/>
&nbsp; // recommendation to give if task skew is detected, and there is no input data.<br/>
&nbsp; private val taskSkewGenericRecommendation = DEFAULT_TASK_SKEW_GENERIC_RECOMMENDATION<br/>
<br/>
&nbsp; // recommendation to give if there are long running <a href="../fetcher/status/statusapiv1.scala.html#L180" title="fetcher/status/statusapiv1.scala:180">tasks</a>, and there is a lot of data being<br/>
&nbsp; // processed, and many <a href="../fetcher/status/statusapiv1.scala.html#L133" title="fetcher/status/statusapiv1.scala:133">partitions</a> already. In this case, long running <a href="../fetcher/status/statusapiv1.scala.html#L180" title="fetcher/status/statusapiv1.scala:180">tasks</a> may be expected, but<br/>
&nbsp; // alert the user, in case it is possible to filter out some data.<br/>
&nbsp; private val longTasksLargeDataRecommenation = DEFAULT_LONG_TASKS_LARGE_DATA_RECOMMENDATION<br/>
<br/>
&nbsp; // recommendation to give if there are long running <a href="../fetcher/status/statusapiv1.scala.html#L180" title="fetcher/status/statusapiv1.scala:180">tasks</a>, a reasonable number of <a href="../fetcher/status/statusapiv1.scala.html#L133" title="fetcher/status/statusapiv1.scala:133">partitions</a>,<br/>
&nbsp; // and not too much data processed. In this case, the <a href="../fetcher/status/statusapiv1.scala.html#L180" title="fetcher/status/statusapiv1.scala:180">tasks</a> are slow.<br/>
&nbsp; private val slowTasksRecommendation = DEFAULT_SLOW_TASKS_RECOMMENDATION<br/>
<br/>
&nbsp; // recommendation to give if there are long running <a href="../fetcher/status/statusapiv1.scala.html#L180" title="fetcher/status/statusapiv1.scala:180">tasks</a> and relatively few <a href="../fetcher/status/statusapiv1.scala.html#L133" title="fetcher/status/statusapiv1.scala:133">partitions</a>.<br/>
&nbsp; private val longTasksFewPartitionsRecommendation = DEFAULT_LONG_TASKS_FEW_PARTITIONS_RECOMMENDATION<br/>
<br/>
&nbsp; // recommendation to give if there are long running <a href="../fetcher/status/statusapiv1.scala.html#L180" title="fetcher/status/statusapiv1.scala:180">tasks</a>, input data is being read (and so<br/>
&nbsp; // controlling the number of <a href="../fetcher/status/statusapiv1.scala.html#L180" title="fetcher/status/statusapiv1.scala:180">tasks</a>), and relatively few <a href="../fetcher/status/statusapiv1.scala.html#L133" title="fetcher/status/statusapiv1.scala:133">partitions</a>.<br/>
&nbsp; private val longTasksFewInputPartitionsRecommendation = DEFAULT_LONG_TASKS_FEW_INPUT_PARTITIONS_RECOMMENDATION<br/>
<br/>
<br/>
&nbsp; /** @return list of analysis results for all the stages. */<br/>
<a id="L183">&#x200c;</a>&nbsp; def <span class="linkable">getStageAnalysis</span>(): Seq[<a href="#L28" title="heuristics/StageAnalyzer.scala:28">StageAnalysis</a>] = {<br/>
&nbsp; &nbsp; val appConf: Map[String, String] = data.appConf<br/>
&nbsp; &nbsp; val curNumPartitions = appConf.<a href="../fetcher/SparkRestClient.scala.html#L229" title="fetcher/SparkRestClient.scala:229">get</a>(SPARK_SQL_SHUFFLE_PARTITIONS)<br/>
&nbsp; &nbsp; &nbsp; .map(_.toInt).getOrElse(SPARK_SQL_SHUFFLE_PARTITIONS_DEFAULT)<br/>
<br/>
&nbsp; &nbsp; data.stageData.map { stageData =&gt;<br/>
&nbsp; &nbsp; &nbsp; val medianTime = stageData.<a href="../fetcher/status/statusapiv1.scala.html#L187" title="fetcher/status/statusapiv1.scala:187">taskSummary</a>.collect {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; case distribution =&gt; distribution.<a href="../fetcher/status/statusapiv1.scala.html#L157" title="fetcher/status/statusapiv1.scala:157">executorRunTime</a>(DISTRIBUTION_MEDIAN_IDX)<br/>
&nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; val maxTime = stageData.<a href="../fetcher/status/statusapiv1.scala.html#L187" title="fetcher/status/statusapiv1.scala:187">taskSummary</a>.collect {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; case distribution =&gt; distribution.<a href="../fetcher/status/statusapiv1.scala.html#L157" title="fetcher/status/statusapiv1.scala:157">executorRunTime</a>(DISTRIBUTION_MAX_IDX)<br/>
&nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; val stageDuration = (stageData.<a href="../fetcher/status/statusapiv1.scala.html#L107" title="fetcher/status/statusapiv1.scala:107">submissionTime</a>, stageData.<a href="../fetcher/status/statusapiv1.scala.html#L108" title="fetcher/status/statusapiv1.scala:108">completionTime</a>) match {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; case (Some(<a href="../fetcher/status/statusapiv1.scala.html#L107" title="fetcher/status/statusapiv1.scala:107">submissionTime</a>), Some(<a href="../fetcher/status/statusapiv1.scala.html#L108" title="fetcher/status/statusapiv1.scala:108">completionTime</a>)) =&gt;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Some(<a href="../fetcher/status/statusapiv1.scala.html#L108" title="fetcher/status/statusapiv1.scala:108">completionTime</a>.getTime() - <a href="../fetcher/status/statusapiv1.scala.html#L107" title="fetcher/status/statusapiv1.scala:107">submissionTime</a>.getTime())<br/>
&nbsp; &nbsp; &nbsp; &nbsp; case _ =&gt; None<br/>
&nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; val <a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a> = stageData.<a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a><br/>
&nbsp; &nbsp; &nbsp; val stageTasks = data.taskData.getOrElse(s&quot;$<a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a>-${stageData.<a href="../fetcher/status/statusapiv1.scala.html#L59" title="fetcher/status/statusapiv1.scala:59">attemptId</a>}&quot;, Seq.empty)<br/>
<br/>
&nbsp; &nbsp; &nbsp; val executionMemorySpillResult = <a href="#L222" title="heuristics/StageAnalyzer.scala:222">checkForExecutionMemorySpill</a>(<a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a>, stageData)<br/>
&nbsp; &nbsp; &nbsp; val longTaskResult = <a href="#L385" title="heuristics/StageAnalyzer.scala:385">checkForLongTasks</a>(<a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a>, stageData, medianTime, curNumPartitions)<br/>
&nbsp; &nbsp; &nbsp; val taskSkewResult = <a href="#L283" title="heuristics/StageAnalyzer.scala:283">checkForTaskSkew</a>(<a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a>, stageData, medianTime, maxTime, stageDuration)<br/>
&nbsp; &nbsp; &nbsp; val stageFailureResult = <a href="#L441" title="heuristics/StageAnalyzer.scala:441">checkForStageFailure</a>(stageData)<br/>
&nbsp; &nbsp; &nbsp; val taskFailureResult = <a href="#L464" title="heuristics/StageAnalyzer.scala:464">checkForTaskFailure</a>(<a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a>, stageData, stageTasks)<br/>
&nbsp; &nbsp; &nbsp; val gcResult = <a href="#L587" title="heuristics/StageAnalyzer.scala:587">checkForGC</a>(<a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a>, stageData)<br/>
<br/>
&nbsp; &nbsp; &nbsp; <a href="#L28" title="heuristics/StageAnalyzer.scala:28">StageAnalysis</a>(stageData, Seq(executionMemorySpillResult, longTaskResult,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; taskSkewResult, taskFailureResult, stageFailureResult, gcResult).flatten)<br/>
&nbsp; &nbsp; }<br/>
&nbsp; }<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Check <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a> for execution memory spill.<br/>
&nbsp;&nbsp; *<br/>
&nbsp;&nbsp; * @param <a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a>&nbsp;&nbsp; <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a> ID.<br/>
&nbsp;&nbsp; * @param stageData <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a> data.<br/>
&nbsp;&nbsp; * @return results of execution memory spill analysis for the <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a>.<br/>
&nbsp;&nbsp; */<br/>
<a id="L222">&#x200c;</a>&nbsp; private def <span class="linkable">checkForExecutionMemorySpill</span>(<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a>: Int,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stageData: <a href="../fetcher/status/statusapiv1.scala.html#L148" title="fetcher/status/statusapiv1.scala:148">StageData</a>): Option[<a href="#L31" title="heuristics/StageAnalyzer.scala:31">StageAnalysisResult</a>] = {<br/>
&nbsp; &nbsp; val maxData = Seq(stageData.<a href="../fetcher/status/statusapiv1.scala.html#L70" title="fetcher/status/statusapiv1.scala:70">inputBytes</a>, stageData.<a href="../fetcher/status/statusapiv1.scala.html#L168" title="fetcher/status/statusapiv1.scala:168">shuffleReadBytes</a>,<br/>
&nbsp; &nbsp; &nbsp; stageData.<a href="../fetcher/status/statusapiv1.scala.html#L170" title="fetcher/status/statusapiv1.scala:170">shuffleWriteBytes</a>, stageData.<a href="../fetcher/status/statusapiv1.scala.html#L71" title="fetcher/status/statusapiv1.scala:71">outputBytes</a>).<a href="../utils/AggregatePerfValue.scala.html#L26" title="utils/AggregatePerfValue.scala:26">max</a><br/>
&nbsp; &nbsp; val rawSpillSeverity = executionMemorySpillThresholds.<a href="SeverityThresholds.scala.html#L33" title="heuristics/SeverityThresholds.scala:33">severityOf</a>(<br/>
&nbsp; &nbsp; &nbsp; stageData.<a href="../fetcher/status/statusapiv1.scala.html#L74" title="fetcher/status/statusapiv1.scala:74">memoryBytesSpilled</a> / maxData.toDouble)<br/>
&nbsp; &nbsp; val <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a> = new ArrayBuffer[String]<br/>
&nbsp; &nbsp; if (<a href="#L431" title="heuristics/StageAnalyzer.scala:431">hasSignificantSeverity</a>(rawSpillSeverity)) {<br/>
&nbsp; &nbsp; &nbsp; val <a href="../fetcher/status/statusapiv1.scala.html#L74" title="fetcher/status/statusapiv1.scala:74">memoryBytesSpilled</a> = MemoryFormatUtils.bytesToString(stageData.<a href="../fetcher/status/statusapiv1.scala.html#L74" title="fetcher/status/statusapiv1.scala:74">memoryBytesSpilled</a>)<br/>
&nbsp; &nbsp; &nbsp; val <a href="../fetcher/status/statusapiv1.scala.html#L75" title="fetcher/status/statusapiv1.scala:75">diskBytesSpilled</a> = MemoryFormatUtils.bytesToString(stageData.<a href="../fetcher/status/statusapiv1.scala.html#L75" title="fetcher/status/statusapiv1.scala:75">diskBytesSpilled</a>)<br/>
&nbsp; &nbsp; &nbsp; val ratio = stageData.<a href="../fetcher/status/statusapiv1.scala.html#L74" title="fetcher/status/statusapiv1.scala:74">memoryBytesSpilled</a>.toDouble / stageData.<a href="../fetcher/status/statusapiv1.scala.html#L75" title="fetcher/status/statusapiv1.scala:75">diskBytesSpilled</a><br/>
&nbsp; &nbsp; &nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a> += f&quot;${<a href="#L39" title="heuristics/StageAnalyzer.scala:39">format</a>(stageData)} has $<a href="../fetcher/status/statusapiv1.scala.html#L74" title="fetcher/status/statusapiv1.scala:74">memoryBytesSpilled</a>/${<a href="../fetcher/status/statusapiv1.scala.html#L75" title="fetcher/status/statusapiv1.scala:75">diskBytesSpilled</a>} (memory/disk) spill. (Ratio $ratio%.3f)&quot;<br/>
&nbsp; &nbsp; &nbsp; // if a lot of data is being processed, the severity is supressed, but give information<br/>
&nbsp; &nbsp; &nbsp; // about the spill to the user, so that they know that spill is happening, and can check<br/>
&nbsp; &nbsp; &nbsp; // if the application can be modified to process less data.<br/>
&nbsp; &nbsp; &nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a> += s&quot;${<a href="#L39" title="heuristics/StageAnalyzer.scala:39">format</a>(stageData)} has ${stageData.<a href="../fetcher/status/statusapiv1.scala.html#L112" title="fetcher/status/statusapiv1.scala:112">numTasks</a>} <a href="../fetcher/status/statusapiv1.scala.html#L180" title="fetcher/status/statusapiv1.scala:180">tasks</a>, &quot; +<br/>
&nbsp; &nbsp; &nbsp; &nbsp; s&quot;${MemoryFormatUtils.bytesToString(stageData.<a href="../fetcher/status/statusapiv1.scala.html#L70" title="fetcher/status/statusapiv1.scala:70">inputBytes</a>)} input read, &quot; +<br/>
&nbsp; &nbsp; &nbsp; &nbsp; s&quot;${MemoryFormatUtils.bytesToString(stageData.<a href="../fetcher/status/statusapiv1.scala.html#L168" title="fetcher/status/statusapiv1.scala:168">shuffleReadBytes</a>)} shuffle read, &quot; +<br/>
&nbsp; &nbsp; &nbsp; &nbsp; s&quot;${MemoryFormatUtils.bytesToString(stageData.<a href="../fetcher/status/statusapiv1.scala.html#L170" title="fetcher/status/statusapiv1.scala:170">shuffleWriteBytes</a>)} shuffle write, &quot; +<br/>
&nbsp; &nbsp; &nbsp; &nbsp; s&quot;${MemoryFormatUtils.bytesToString(stageData.<a href="../fetcher/status/statusapiv1.scala.html#L71" title="fetcher/status/statusapiv1.scala:71">outputBytes</a>)} output.&quot;<br/>
<br/>
&nbsp; &nbsp; &nbsp; if (stageData.<a href="../fetcher/status/statusapiv1.scala.html#L187" title="fetcher/status/statusapiv1.scala:187">taskSummary</a>.isDefined) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; val summary = stageData.<a href="../fetcher/status/statusapiv1.scala.html#L187" title="fetcher/status/statusapiv1.scala:187">taskSummary</a>.<a href="../fetcher/SparkRestClient.scala.html#L229" title="fetcher/SparkRestClient.scala:229">get</a><br/>
&nbsp; &nbsp; &nbsp; &nbsp; val memorySpill = summary.<a href="../fetcher/status/statusapiv1.scala.html#L74" title="fetcher/status/statusapiv1.scala:74">memoryBytesSpilled</a>(DISTRIBUTION_MEDIAN_IDX).toLong<br/>
&nbsp; &nbsp; &nbsp; &nbsp; val <a href="../fetcher/status/statusapiv1.scala.html#L70" title="fetcher/status/statusapiv1.scala:70">inputBytes</a> = summary.<a href="../fetcher/status/statusapiv1.scala.html#L212" title="fetcher/status/statusapiv1.scala:212">inputMetrics</a>.<a href="../fetcher/status/statusapiv1.scala.html#L218" title="fetcher/status/statusapiv1.scala:218">bytesRead</a>(DISTRIBUTION_MEDIAN_IDX).toLong<br/>
&nbsp; &nbsp; &nbsp; &nbsp; val <a href="../fetcher/status/statusapiv1.scala.html#L71" title="fetcher/status/statusapiv1.scala:71">outputBytes</a> = summary.<a href="../fetcher/status/statusapiv1.scala.html#L213" title="fetcher/status/statusapiv1.scala:213">outputMetrics</a>.<a href="../fetcher/status/statusapiv1.scala.html#L222" title="fetcher/status/statusapiv1.scala:222">bytesWritten</a>(DISTRIBUTION_MEDIAN_IDX).toLong<br/>
&nbsp; &nbsp; &nbsp; &nbsp; val <a href="../fetcher/status/statusapiv1.scala.html#L168" title="fetcher/status/statusapiv1.scala:168">shuffleReadBytes</a> = summary.<a href="../fetcher/status/statusapiv1.scala.html#L214" title="fetcher/status/statusapiv1.scala:214">shuffleReadMetrics</a>.<a href="../fetcher/status/statusapiv1.scala.html#L268" title="fetcher/status/statusapiv1.scala:268">readBytes</a>(DISTRIBUTION_MEDIAN_IDX).toLong<br/>
&nbsp; &nbsp; &nbsp; &nbsp; val <a href="../fetcher/status/statusapiv1.scala.html#L170" title="fetcher/status/statusapiv1.scala:170">shuffleWriteBytes</a> = summary.<a href="../fetcher/status/statusapiv1.scala.html#L215" title="fetcher/status/statusapiv1.scala:215">shuffleWriteMetrics</a>.<a href="../fetcher/status/statusapiv1.scala.html#L278" title="fetcher/status/statusapiv1.scala:278">writeBytes</a>(DISTRIBUTION_MEDIAN_IDX).toLong<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a> += s&quot;${<a href="#L39" title="heuristics/StageAnalyzer.scala:39">format</a>(stageData)} has median task values: &quot; +<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s&quot;${MemoryFormatUtils.bytesToString(memorySpill)} memory spill, &quot; +<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s&quot;${MemoryFormatUtils.bytesToString(<a href="../fetcher/status/statusapiv1.scala.html#L70" title="fetcher/status/statusapiv1.scala:70">inputBytes</a>)} input, &quot; +<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s&quot;${MemoryFormatUtils.bytesToString(<a href="../fetcher/status/statusapiv1.scala.html#L168" title="fetcher/status/statusapiv1.scala:168">shuffleReadBytes</a>)} shuffle read, &quot; +<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s&quot;${MemoryFormatUtils.bytesToString(<a href="../fetcher/status/statusapiv1.scala.html#L170" title="fetcher/status/statusapiv1.scala:170">shuffleWriteBytes</a>)} shuffle write, &quot; +<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s&quot;${MemoryFormatUtils.bytesToString(<a href="../fetcher/status/statusapiv1.scala.html#L71" title="fetcher/status/statusapiv1.scala:71">outputBytes</a>)} output.&quot;<br/>
&nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; val maxTaskSpill = stageData.<a href="../fetcher/status/statusapiv1.scala.html#L187" title="fetcher/status/statusapiv1.scala:187">taskSummary</a>.collect {<br/>
&nbsp; &nbsp; &nbsp; case distribution =&gt; distribution.<a href="../fetcher/status/statusapiv1.scala.html#L74" title="fetcher/status/statusapiv1.scala:74">memoryBytesSpilled</a>(DISTRIBUTION_MAX_IDX)<br/>
&nbsp; &nbsp; }.map(_.toLong).getOrElse(0L)<br/>
<br/>
&nbsp; &nbsp; if (<a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a>.nonEmpty) {<br/>
&nbsp; &nbsp; &nbsp; Some(<a href="#L78" title="heuristics/StageAnalyzer.scala:78">ExecutionMemorySpillResult</a>(stageData, <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a>,<br/>
&nbsp; &nbsp; &nbsp; stageData.<a href="../fetcher/status/statusapiv1.scala.html#L74" title="fetcher/status/statusapiv1.scala:74">memoryBytesSpilled</a>, maxTaskSpill))<br/>
&nbsp; &nbsp; } else {<br/>
&nbsp; &nbsp; &nbsp; None<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; }<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Check <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a> for task skew.<br/>
&nbsp;&nbsp; *<br/>
&nbsp;&nbsp; * @param <a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a> ID.<br/>
&nbsp;&nbsp; * @param stageData&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a> data<br/>
&nbsp;&nbsp; * @param medianTime&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; median task run time (ms).<br/>
&nbsp;&nbsp; * @param maxTime&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maximum task run time (ms).<br/>
&nbsp;&nbsp; * @param stageDuration&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a> duration (ms).<br/>
&nbsp;&nbsp; * @return results of task skew analysis for the <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a>.<br/>
&nbsp;&nbsp; */<br/>
<a id="L283">&#x200c;</a>&nbsp; private def <span class="linkable">checkForTaskSkew</span>(<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a>: Int,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stageData: <a href="../fetcher/status/statusapiv1.scala.html#L148" title="fetcher/status/statusapiv1.scala:148">StageData</a>,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; medianTime: Option[Double],<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxTime: Option[Double],<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stageDuration: Option[Long]): Option[<a href="#L58" title="heuristics/StageAnalyzer.scala:58">TaskSkewResult</a>] = {<br/>
&nbsp; &nbsp; val rawSkewSeverity = (medianTime, maxTime) match {<br/>
&nbsp; &nbsp; &nbsp; case (Some(median), Some(<a href="../utils/AggregatePerfValue.scala.html#L26" title="utils/AggregatePerfValue.scala:26">max</a>)) =&gt;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; taskSkewThresholds.<a href="SeverityThresholds.scala.html#L33" title="heuristics/SeverityThresholds.scala:33">severityOf</a>(<a href="../utils/AggregatePerfValue.scala.html#L26" title="utils/AggregatePerfValue.scala:26">max</a> / median)<br/>
&nbsp; &nbsp; &nbsp; case _ =&gt; Severity.NONE<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; val maximum = maxTime.getOrElse(0.0D)<br/>
&nbsp; &nbsp; val taskSkewSeverity =<br/>
&nbsp; &nbsp; &nbsp; if (maximum &gt; taskDurationMinThreshold &amp;&amp;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; maximum &gt; longTaskToStageDurationRatio * stageDuration.getOrElse(Long.MaxValue)) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; rawSkewSeverity<br/>
&nbsp; &nbsp; &nbsp; } else {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Severity.NONE<br/>
&nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; val <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a> = new ArrayBuffer[String]<br/>
<br/>
&nbsp; &nbsp; // add more information about what might be causing skew if skew is being flagged<br/>
&nbsp; &nbsp; // (reported severity is significant), or there is execution memory spill, since skew<br/>
&nbsp; &nbsp; // can also cause execution memory spill.<br/>
&nbsp; &nbsp; val medianStr = Utils.getDuration(medianTime.map(_.toLong).getOrElse(0L))<br/>
&nbsp; &nbsp; val maximumStr = Utils.getDuration(maxTime.map(_.toLong).getOrElse(0L))<br/>
&nbsp; &nbsp; var inputSkewSeverity = Severity.NONE<br/>
&nbsp; &nbsp; if (<a href="#L431" title="heuristics/StageAnalyzer.scala:431">hasSignificantSeverity</a>(taskSkewSeverity)) {<br/>
&nbsp; &nbsp; &nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a> +=<br/>
&nbsp; &nbsp; &nbsp; &nbsp; s&quot;${<a href="#L39" title="heuristics/StageAnalyzer.scala:39">format</a>(stageData)} has skew in task run time (median is $medianStr, <a href="../utils/AggregatePerfValue.scala.html#L26" title="utils/AggregatePerfValue.scala:26">max</a> is $maximumStr).&quot;<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; stageData.<a href="../fetcher/status/statusapiv1.scala.html#L187" title="fetcher/status/statusapiv1.scala:187">taskSummary</a>.foreach { summary =&gt;<br/>
&nbsp; &nbsp; &nbsp; <a href="#L360" title="heuristics/StageAnalyzer.scala:360">checkSkewedData</a>(<a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a>, summary.<a href="../fetcher/status/statusapiv1.scala.html#L74" title="fetcher/status/statusapiv1.scala:74">memoryBytesSpilled</a>(DISTRIBUTION_MEDIAN_IDX),<br/>
&nbsp; &nbsp; &nbsp; &nbsp; summary.<a href="../fetcher/status/statusapiv1.scala.html#L74" title="fetcher/status/statusapiv1.scala:74">memoryBytesSpilled</a>(DISTRIBUTION_MAX_IDX), &quot;memory bytes spilled&quot;, <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a>)<br/>
<br/>
&nbsp; &nbsp; &nbsp; val input = summary.<a href="../fetcher/status/statusapiv1.scala.html#L212" title="fetcher/status/statusapiv1.scala:212">inputMetrics</a><br/>
&nbsp; &nbsp; &nbsp; inputSkewSeverity = <a href="#L360" title="heuristics/StageAnalyzer.scala:360">checkSkewedData</a>(<a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a>, input.<a href="../fetcher/status/statusapiv1.scala.html#L218" title="fetcher/status/statusapiv1.scala:218">bytesRead</a>(DISTRIBUTION_MEDIAN_IDX),<br/>
&nbsp; &nbsp; &nbsp; &nbsp; input.<a href="../fetcher/status/statusapiv1.scala.html#L218" title="fetcher/status/statusapiv1.scala:218">bytesRead</a>(DISTRIBUTION_MAX_IDX), &quot;task input bytes&quot;, <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a>)<br/>
&nbsp; &nbsp; &nbsp; if (<a href="#L431" title="heuristics/StageAnalyzer.scala:431">hasSignificantSeverity</a>(inputSkewSeverity)) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; // The <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a> is reading input data, try to adjust the amount of data to even the <a href="../fetcher/status/statusapiv1.scala.html#L133" title="fetcher/status/statusapiv1.scala:133">partitions</a><br/>
&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a> += s&quot;${<a href="#L39" title="heuristics/StageAnalyzer.scala:39">format</a>(stageData)}: ${taskSkewInputDataRecommendation}.&quot;<br/>
&nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; val output = summary.<a href="../fetcher/status/statusapiv1.scala.html#L213" title="fetcher/status/statusapiv1.scala:213">outputMetrics</a><br/>
&nbsp; &nbsp; &nbsp; <a href="#L360" title="heuristics/StageAnalyzer.scala:360">checkSkewedData</a>(<a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a>, output.<a href="../fetcher/status/statusapiv1.scala.html#L222" title="fetcher/status/statusapiv1.scala:222">bytesWritten</a>(DISTRIBUTION_MEDIAN_IDX),<br/>
&nbsp; &nbsp; &nbsp; &nbsp; output.<a href="../fetcher/status/statusapiv1.scala.html#L222" title="fetcher/status/statusapiv1.scala:222">bytesWritten</a>(DISTRIBUTION_MAX_IDX), &quot;task output bytes&quot;, <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a>)<br/>
<br/>
&nbsp; &nbsp; &nbsp; val <a href="../fetcher/status/statusapiv1.scala.html#L72" title="fetcher/status/statusapiv1.scala:72">shuffleRead</a> = summary.<a href="../fetcher/status/statusapiv1.scala.html#L214" title="fetcher/status/statusapiv1.scala:214">shuffleReadMetrics</a><br/>
&nbsp; &nbsp; &nbsp; <a href="#L360" title="heuristics/StageAnalyzer.scala:360">checkSkewedData</a>(<a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a>, <a href="../fetcher/status/statusapiv1.scala.html#L72" title="fetcher/status/statusapiv1.scala:72">shuffleRead</a>.<a href="../fetcher/status/statusapiv1.scala.html#L268" title="fetcher/status/statusapiv1.scala:268">readBytes</a>(DISTRIBUTION_MEDIAN_IDX),<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L72" title="fetcher/status/statusapiv1.scala:72">shuffleRead</a>.<a href="../fetcher/status/statusapiv1.scala.html#L268" title="fetcher/status/statusapiv1.scala:268">readBytes</a>(DISTRIBUTION_MAX_IDX), &quot;task shuffle read bytes&quot;, <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a>)<br/>
<br/>
&nbsp; &nbsp; &nbsp; val <a href="../fetcher/status/statusapiv1.scala.html#L73" title="fetcher/status/statusapiv1.scala:73">shuffleWrite</a> = summary.<a href="../fetcher/status/statusapiv1.scala.html#L215" title="fetcher/status/statusapiv1.scala:215">shuffleWriteMetrics</a><br/>
&nbsp; &nbsp; &nbsp; <a href="#L360" title="heuristics/StageAnalyzer.scala:360">checkSkewedData</a>(<a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a>, <a href="../fetcher/status/statusapiv1.scala.html#L73" title="fetcher/status/statusapiv1.scala:73">shuffleWrite</a>.<a href="../fetcher/status/statusapiv1.scala.html#L278" title="fetcher/status/statusapiv1.scala:278">writeBytes</a>(DISTRIBUTION_MEDIAN_IDX),<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L73" title="fetcher/status/statusapiv1.scala:73">shuffleWrite</a>.<a href="../fetcher/status/statusapiv1.scala.html#L278" title="fetcher/status/statusapiv1.scala:278">writeBytes</a>(DISTRIBUTION_MAX_IDX), &quot;task shuffle write bytes&quot;, <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a>)<br/>
<br/>
&nbsp; &nbsp; &nbsp; if (<a href="#L431" title="heuristics/StageAnalyzer.scala:431">hasSignificantSeverity</a>(rawSkewSeverity) &amp;&amp; !<a href="#L431" title="heuristics/StageAnalyzer.scala:431">hasSignificantSeverity</a>(inputSkewSeverity)) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a> += s&quot;${<a href="#L39" title="heuristics/StageAnalyzer.scala:39">format</a>(stageData)}: ${taskSkewGenericRecommendation}.&quot;<br/>
&nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; if(<a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a>.nonEmpty) {<br/>
&nbsp; &nbsp; &nbsp; Some(<a href="#L58" title="heuristics/StageAnalyzer.scala:58">TaskSkewResult</a>(stageData, <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a>))<br/>
&nbsp; &nbsp; } else {<br/>
&nbsp; &nbsp; &nbsp; None<br/>
&nbsp; &nbsp; }<br/>
&nbsp; }<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Check for skewed data.<br/>
&nbsp;&nbsp; *<br/>
&nbsp;&nbsp; * @param <a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a>&nbsp; &nbsp;&nbsp; <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a> ID<br/>
&nbsp;&nbsp; * @param median&nbsp; &nbsp; &nbsp; median data size for <a href="../fetcher/status/statusapiv1.scala.html#L180" title="fetcher/status/statusapiv1.scala:180">tasks</a>.<br/>
&nbsp;&nbsp; * @param maximum&nbsp; &nbsp;&nbsp; maximum data size for <a href="../fetcher/status/statusapiv1.scala.html#L180" title="fetcher/status/statusapiv1.scala:180">tasks</a>.<br/>
&nbsp;&nbsp; * @param <a href="../fetcher/status/statusapiv1.scala.html#L106" title="fetcher/status/statusapiv1.scala:106">description</a> type of data.<br/>
&nbsp;&nbsp; * @param <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a>&nbsp; &nbsp;&nbsp; information and recommendations -- any new recommendations<br/>
&nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; from analyzing the <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a> for data skew will be appended.<br/>
&nbsp;&nbsp; */<br/>
<a id="L360">&#x200c;</a>&nbsp; private def <span class="linkable">checkSkewedData</span>(<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a>: Int,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; median: Double,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; maximum: Double,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L106" title="fetcher/status/statusapiv1.scala:106">description</a>: String,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a>: ArrayBuffer[String]): Severity = {<br/>
&nbsp; &nbsp; val severity = taskSkewThresholds.<a href="SeverityThresholds.scala.html#L33" title="heuristics/SeverityThresholds.scala:33">severityOf</a>(maximum / median)<br/>
&nbsp; &nbsp; if (<a href="#L431" title="heuristics/StageAnalyzer.scala:431">hasSignificantSeverity</a>(severity)) {<br/>
&nbsp; &nbsp; &nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a> += s&quot;Stage $<a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a> has skew in $<a href="../fetcher/status/statusapiv1.scala.html#L106" title="fetcher/status/statusapiv1.scala:106">description</a> (median is &quot; +<br/>
&nbsp; &nbsp; &nbsp; &nbsp; s&quot;${MemoryFormatUtils.bytesToString(median.toLong)}, &quot; +<br/>
&nbsp; &nbsp; &nbsp; &nbsp; s&quot;<a href="../utils/AggregatePerfValue.scala.html#L26" title="utils/AggregatePerfValue.scala:26">max</a> is ${MemoryFormatUtils.bytesToString(maximum.toLong)}).&quot;<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; severity<br/>
&nbsp; }<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Check the <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a> for long running <a href="../fetcher/status/statusapiv1.scala.html#L180" title="fetcher/status/statusapiv1.scala:180">tasks</a>.<br/>
&nbsp;&nbsp; *<br/>
&nbsp;&nbsp; * @param <a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a> ID.<br/>
&nbsp;&nbsp; * @param stageData&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a> data.<br/>
&nbsp;&nbsp; * @param medianTime&nbsp; &nbsp; &nbsp;&nbsp; median task run time.<br/>
&nbsp;&nbsp; * @param curNumPartitions number of <a href="../fetcher/status/statusapiv1.scala.html#L133" title="fetcher/status/statusapiv1.scala:133">partitions</a> for the Spark application<br/>
&nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (spark.sql.shuffle.<a href="../fetcher/status/statusapiv1.scala.html#L133" title="fetcher/status/statusapiv1.scala:133">partitions</a>).<br/>
&nbsp;&nbsp; * @return results of long running task analysis for the <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a><br/>
&nbsp;&nbsp; */<br/>
<a id="L385">&#x200c;</a>&nbsp; private def <span class="linkable">checkForLongTasks</span>(<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a>: Int,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stageData: <a href="../fetcher/status/statusapiv1.scala.html#L148" title="fetcher/status/statusapiv1.scala:148">StageData</a>,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; medianTime: Option[Double],<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curNumPartitions: Int): Option[<a href="#L43" title="heuristics/StageAnalyzer.scala:43">SimpleStageAnalysisResult</a>] = {<br/>
&nbsp; &nbsp; val longTaskSeverity = stageData.<a href="../fetcher/status/statusapiv1.scala.html#L187" title="fetcher/status/statusapiv1.scala:187">taskSummary</a>.map { distributions =&gt;<br/>
&nbsp; &nbsp; &nbsp; taskDurationThresholds.<a href="SeverityThresholds.scala.html#L33" title="heuristics/SeverityThresholds.scala:33">severityOf</a>(distributions.<a href="../fetcher/status/statusapiv1.scala.html#L157" title="fetcher/status/statusapiv1.scala:157">executorRunTime</a>(DISTRIBUTION_MEDIAN_IDX))<br/>
&nbsp; &nbsp; }.getOrElse(Severity.NONE)<br/>
&nbsp; &nbsp; val <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a> = new ArrayBuffer[String]<br/>
&nbsp; &nbsp; if (<a href="#L431" title="heuristics/StageAnalyzer.scala:431">hasSignificantSeverity</a>(longTaskSeverity)) {<br/>
&nbsp; &nbsp; &nbsp; val runTime = Utils.getDuration(medianTime.map(_.toLong).getOrElse(0L))<br/>
&nbsp; &nbsp; &nbsp; val maxData = Seq(stageData.<a href="../fetcher/status/statusapiv1.scala.html#L70" title="fetcher/status/statusapiv1.scala:70">inputBytes</a>, stageData.<a href="../fetcher/status/statusapiv1.scala.html#L168" title="fetcher/status/statusapiv1.scala:168">shuffleReadBytes</a>, stageData.<a href="../fetcher/status/statusapiv1.scala.html#L170" title="fetcher/status/statusapiv1.scala:170">shuffleWriteBytes</a>,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; stageData.<a href="../fetcher/status/statusapiv1.scala.html#L71" title="fetcher/status/statusapiv1.scala:71">outputBytes</a>).<a href="../utils/AggregatePerfValue.scala.html#L26" title="utils/AggregatePerfValue.scala:26">max</a><br/>
&nbsp; &nbsp; &nbsp; val <a href="../fetcher/status/statusapiv1.scala.html#L70" title="fetcher/status/statusapiv1.scala:70">inputBytes</a> = MemoryFormatUtils.bytesToString(stageData.<a href="../fetcher/status/statusapiv1.scala.html#L70" title="fetcher/status/statusapiv1.scala:70">inputBytes</a>)<br/>
&nbsp; &nbsp; &nbsp; val <a href="../fetcher/status/statusapiv1.scala.html#L71" title="fetcher/status/statusapiv1.scala:71">outputBytes</a> = MemoryFormatUtils.bytesToString(stageData.<a href="../fetcher/status/statusapiv1.scala.html#L71" title="fetcher/status/statusapiv1.scala:71">outputBytes</a>)<br/>
&nbsp; &nbsp; &nbsp; val <a href="../fetcher/status/statusapiv1.scala.html#L168" title="fetcher/status/statusapiv1.scala:168">shuffleReadBytes</a> = MemoryFormatUtils.bytesToString(stageData.<a href="../fetcher/status/statusapiv1.scala.html#L168" title="fetcher/status/statusapiv1.scala:168">shuffleReadBytes</a>)<br/>
&nbsp; &nbsp; &nbsp; val <a href="../fetcher/status/statusapiv1.scala.html#L170" title="fetcher/status/statusapiv1.scala:170">shuffleWriteBytes</a> = MemoryFormatUtils.bytesToString(stageData.<a href="../fetcher/status/statusapiv1.scala.html#L170" title="fetcher/status/statusapiv1.scala:170">shuffleWriteBytes</a>)<br/>
&nbsp; &nbsp; &nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a> += s&quot;Stage $<a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a> has a long median task run time of $runTime.&quot;<br/>
&nbsp; &nbsp; &nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a> += s&quot;Stage $<a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a> has ${stageData.<a href="../fetcher/status/statusapiv1.scala.html#L112" title="fetcher/status/statusapiv1.scala:112">numTasks</a>} <a href="../fetcher/status/statusapiv1.scala.html#L180" title="fetcher/status/statusapiv1.scala:180">tasks</a>, $<a href="../fetcher/status/statusapiv1.scala.html#L70" title="fetcher/status/statusapiv1.scala:70">inputBytes</a> input,&quot; +<br/>
&nbsp; &nbsp; &nbsp; &nbsp; s&quot; $<a href="../fetcher/status/statusapiv1.scala.html#L168" title="fetcher/status/statusapiv1.scala:168">shuffleReadBytes</a> shuffle read, $<a href="../fetcher/status/statusapiv1.scala.html#L170" title="fetcher/status/statusapiv1.scala:170">shuffleWriteBytes</a> shuffle write, and $<a href="../fetcher/status/statusapiv1.scala.html#L71" title="fetcher/status/statusapiv1.scala:71">outputBytes</a> output.&quot;<br/>
&nbsp; &nbsp; &nbsp; if (stageData.<a href="../fetcher/status/statusapiv1.scala.html#L112" title="fetcher/status/statusapiv1.scala:112">numTasks</a> &gt;= maxRecommendedPartitions) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; if (maxData &gt;= maxDataProcessedThreshold) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a> += s&quot;Stage $<a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a>: ${longTasksLargeDataRecommenation}.&quot;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; } else {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a> += s&quot;Stage $<a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a>: ${slowTasksRecommendation}.&quot;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; else {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; if (stageData.<a href="../fetcher/status/statusapiv1.scala.html#L70" title="fetcher/status/statusapiv1.scala:70">inputBytes</a> &gt; 0) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // The <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a> is reading input data, try to increase the number of readers<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a> += s&quot;Stage $<a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a>: ${longTasksFewInputPartitionsRecommendation}.&quot;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; } else if (stageData.<a href="../fetcher/status/statusapiv1.scala.html#L112" title="fetcher/status/statusapiv1.scala:112">numTasks</a> != curNumPartitions) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a> += s&quot;Stage $<a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a>: ${longTasksFewPartitionsRecommendation}.&quot;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; if (<a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a>.nonEmpty) {<br/>
&nbsp; &nbsp; &nbsp; Some(<a href="#L43" title="heuristics/StageAnalyzer.scala:43">SimpleStageAnalysisResult</a>(&quot;Long Task&quot;, stageData, <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a>))<br/>
&nbsp; &nbsp; } else {<br/>
&nbsp; &nbsp; &nbsp; None<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; }<br/>
<br/>
&nbsp; /** Given the severity, return true if the severity is not NONE or LOW. */<br/>
<a id="L431">&#x200c;</a>&nbsp; private def <span class="linkable">hasSignificantSeverity</span>(severity: Severity): Boolean = {<br/>
&nbsp; &nbsp; severity != Severity.NONE &amp;&amp; severity != Severity.LOW<br/>
&nbsp; }<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Check for <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a> <a href="../utils/spark/PerJobReport.scala.html#L33" title="utils/spark/PerJobReport.scala:33">failure</a>.<br/>
&nbsp;&nbsp; *<br/>
&nbsp;&nbsp; * @param stageData <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a> data.<br/>
&nbsp;&nbsp; * @return results of <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a> <a href="../utils/spark/PerJobReport.scala.html#L33" title="utils/spark/PerJobReport.scala:33">failure</a> analysis for the <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a>.<br/>
&nbsp;&nbsp; */<br/>
<a id="L441">&#x200c;</a>&nbsp; private def <span class="linkable">checkForStageFailure</span>(stageData: <a href="../fetcher/status/statusapiv1.scala.html#L148" title="fetcher/status/statusapiv1.scala:148">StageData</a>): Option[<a href="#L31" title="heuristics/StageAnalyzer.scala:31">StageAnalysisResult</a>] = {<br/>
&nbsp; &nbsp; val <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a> = stageData.<a href="../fetcher/status/statusapiv1.scala.html#L162" title="fetcher/status/statusapiv1.scala:162">failureReason</a><br/>
&nbsp; &nbsp; &nbsp; .map(reason =&gt; s&quot;${<a href="#L39" title="heuristics/StageAnalyzer.scala:39">format</a>(stageData)} failed: ${<a href="#L519" title="heuristics/StageAnalyzer.scala:519">getMessage</a>(reason)}&quot;)<br/>
&nbsp; &nbsp; &nbsp; .toSeq<br/>
<br/>
&nbsp; &nbsp; if (<a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a>.nonEmpty) {<br/>
&nbsp; &nbsp; &nbsp; Some(<a href="#L43" title="heuristics/StageAnalyzer.scala:43">SimpleStageAnalysisResult</a>(&quot;Stage Failure&quot;, stageData, <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a>))<br/>
&nbsp; &nbsp; } else {<br/>
&nbsp; &nbsp; &nbsp; None<br/>
&nbsp; &nbsp; }<br/>
&nbsp; }<br/>
<br/>
<a id="L453">&#x200c;</a>&nbsp; private def <span class="linkable">format</span>(stageData: <a href="../fetcher/status/statusapiv1.scala.html#L148" title="fetcher/status/statusapiv1.scala:148">StageData</a>): String =<br/>
&nbsp; &nbsp; s&quot;Stage ${stageData.<a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a>} (Attempt ${stageData.<a href="../fetcher/status/statusapiv1.scala.html#L59" title="fetcher/status/statusapiv1.scala:59">attemptId</a>}) : ${stageData.<a href="../fetcher/status/statusapiv1.scala.html#L48" title="fetcher/status/statusapiv1.scala:48">name</a>}&quot;<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Check for failed <a href="../fetcher/status/statusapiv1.scala.html#L180" title="fetcher/status/statusapiv1.scala:180">tasks</a>, including failures caused by OutOfMemory errors, and containers<br/>
&nbsp;&nbsp; * killed by YARN for exceeding memory limits.<br/>
&nbsp;&nbsp; *<br/>
&nbsp;&nbsp; * @param <a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a>&nbsp;&nbsp; <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a> ID.<br/>
&nbsp;&nbsp; * @param stageData <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a> data.<br/>
&nbsp;&nbsp; * @return result of failed <a href="../fetcher/status/statusapiv1.scala.html#L180" title="fetcher/status/statusapiv1.scala:180">tasks</a> analysis for the <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a>.<br/>
&nbsp;&nbsp; */<br/>
<a id="L464">&#x200c;</a>&nbsp; private def <span class="linkable">checkForTaskFailure</span>(<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a>: Int,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stageData: <a href="../fetcher/status/statusapiv1.scala.html#L148" title="fetcher/status/statusapiv1.scala:148">StageData</a>,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; taskData: Seq[<a href="../fetcher/status/statusapiv1.scala.html#L190" title="fetcher/status/statusapiv1.scala:190">TaskData</a>]<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ): Option[<a href="#L98" title="heuristics/StageAnalyzer.scala:98">TaskFailureResult</a>] = {<br/>
&nbsp; &nbsp; val <a href="../fetcher/status/statusapiv1.scala.html#L68" title="fetcher/status/statusapiv1.scala:68">failedTasks</a> = taskData.filter(_.<a href="../fetcher/status/statusapiv1.scala.html#L111" title="fetcher/status/statusapiv1.scala:111">status</a> == &quot;FAILED&quot;)<br/>
<br/>
&nbsp; &nbsp; if (<a href="../fetcher/status/statusapiv1.scala.html#L68" title="fetcher/status/statusapiv1.scala:68">failedTasks</a>.isEmpty) {<br/>
&nbsp; &nbsp; &nbsp; None<br/>
&nbsp; &nbsp; } else {<br/>
&nbsp; &nbsp; &nbsp; val <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a> = new ArrayBuffer[String]()<br/>
<br/>
&nbsp; &nbsp; &nbsp; val taskFailureRate = stageData.<a href="../fetcher/status/statusapiv1.scala.html#L116" title="fetcher/status/statusapiv1.scala:116">numFailedTasks</a>.toDouble / stageData.<a href="../fetcher/status/statusapiv1.scala.html#L112" title="fetcher/status/statusapiv1.scala:112">numTasks</a><br/>
<br/>
&nbsp; &nbsp; &nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a> += f&quot;${<a href="#L39" title="heuristics/StageAnalyzer.scala:39">format</a>(stageData)} has ${stageData.<a href="../fetcher/status/statusapiv1.scala.html#L116" title="fetcher/status/statusapiv1.scala:116">numFailedTasks</a>} failed <a href="../fetcher/status/statusapiv1.scala.html#L180" title="fetcher/status/statusapiv1.scala:180">tasks</a> of ${stageData.<a href="../fetcher/status/statusapiv1.scala.html#L112" title="fetcher/status/statusapiv1.scala:112">numTasks</a>} (Failure rate ${taskFailureRate}%.3f).&quot;<br/>
<br/>
&nbsp; &nbsp; &nbsp; Some(<a href="#L98" title="heuristics/StageAnalyzer.scala:98">TaskFailureResult</a>(<br/>
&nbsp; &nbsp; &nbsp; &nbsp; stageData,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a>,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L488" title="heuristics/StageAnalyzer.scala:488">groupByMessage</a>(<a href="../fetcher/status/statusapiv1.scala.html#L68" title="fetcher/status/statusapiv1.scala:68">failedTasks</a>),<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L507" title="heuristics/StageAnalyzer.scala:507">groupByTargetHost</a>(<a href="../fetcher/status/statusapiv1.scala.html#L68" title="fetcher/status/statusapiv1.scala:68">failedTasks</a>)))<br/>
&nbsp; &nbsp; }<br/>
&nbsp; }<br/>
<br/>
<a id="L488">&#x200c;</a>&nbsp; private def <span class="linkable">groupByMessage</span>(<a href="../fetcher/status/statusapiv1.scala.html#L68" title="fetcher/status/statusapiv1.scala:68">failedTasks</a>: Iterable[<a href="../fetcher/status/statusapiv1.scala.html#L190" title="fetcher/status/statusapiv1.scala:190">TaskData</a>]): Map[String, Int] = {<br/>
&nbsp; &nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L68" title="fetcher/status/statusapiv1.scala:68">failedTasks</a><br/>
&nbsp; &nbsp; &nbsp; .flatMap(_.<a href="../fetcher/status/statusapiv1.scala.html#L201" title="fetcher/status/statusapiv1.scala:201">errorMessage</a>)<br/>
&nbsp; &nbsp; &nbsp; .map(<a href="#L519" title="heuristics/StageAnalyzer.scala:519">getMessage</a>)<br/>
&nbsp; &nbsp; &nbsp; .toSeq<br/>
&nbsp; &nbsp; &nbsp; .sortWith(_.compareTo(_) &lt; 0)<br/>
&nbsp; &nbsp; &nbsp; .groupBy(identity)<br/>
&nbsp; &nbsp; &nbsp; .mapValues(_.size)<br/>
&nbsp; }<br/>
<br/>
<a id="L498">&#x200c;</a>&nbsp; private def <span class="linkable">groupByHost</span>(<a href="../fetcher/status/statusapiv1.scala.html#L68" title="fetcher/status/statusapiv1.scala:68">failedTasks</a>: Iterable[<a href="../fetcher/status/statusapiv1.scala.html#L190" title="fetcher/status/statusapiv1.scala:190">TaskData</a>]): Map[String, Int] = {<br/>
&nbsp; &nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L68" title="fetcher/status/statusapiv1.scala:68">failedTasks</a><br/>
&nbsp; &nbsp; &nbsp; .map(_.<a href="../fetcher/status/statusapiv1.scala.html#L196" title="fetcher/status/statusapiv1.scala:196">host</a>)<br/>
&nbsp; &nbsp; &nbsp; .toSeq<br/>
&nbsp; &nbsp; &nbsp; .sortWith(_.compareTo(_) &lt; 0)<br/>
&nbsp; &nbsp; &nbsp; .groupBy(identity)<br/>
&nbsp; &nbsp; &nbsp; .mapValues(_.size)<br/>
&nbsp; }<br/>
<br/>
<a id="L507">&#x200c;</a>&nbsp; private def <span class="linkable">groupByTargetHost</span>(<a href="../fetcher/status/statusapiv1.scala.html#L68" title="fetcher/status/statusapiv1.scala:68">failedTasks</a>: Iterable[<a href="../fetcher/status/statusapiv1.scala.html#L190" title="fetcher/status/statusapiv1.scala:190">TaskData</a>]): Map[String, Int] = {<br/>
&nbsp; &nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L68" title="fetcher/status/statusapiv1.scala:68">failedTasks</a><br/>
&nbsp; &nbsp; &nbsp; .filter(_.<a href="../fetcher/status/statusapiv1.scala.html#L201" title="fetcher/status/statusapiv1.scala:201">errorMessage</a>.isDefined)<br/>
&nbsp; &nbsp; &nbsp; .map(_.<a href="../fetcher/status/statusapiv1.scala.html#L201" title="fetcher/status/statusapiv1.scala:201">errorMessage</a>.<a href="../fetcher/SparkRestClient.scala.html#L229" title="fetcher/SparkRestClient.scala:229">get</a>)<br/>
&nbsp; &nbsp; &nbsp; .map(<a href="#L519" title="heuristics/StageAnalyzer.scala:519">getMessage</a>)<br/>
&nbsp; &nbsp; &nbsp; .flatMap(<a href="#L529" title="heuristics/StageAnalyzer.scala:529">getTargetHost</a>)<br/>
&nbsp; &nbsp; &nbsp; .toSeq<br/>
&nbsp; &nbsp; &nbsp; .sortWith(_.compareTo(_) &lt; 0)<br/>
&nbsp; &nbsp; &nbsp; .groupBy(identity)<br/>
&nbsp; &nbsp; &nbsp; .mapValues(_.size)<br/>
&nbsp; }<br/>
<br/>
<a id="L519">&#x200c;</a>&nbsp; private def <span class="linkable">getMessage</span>(<a href="../fetcher/status/statusapiv1.scala.html#L201" title="fetcher/status/statusapiv1.scala:201">errorMessage</a>: String): String = {<br/>
&nbsp; &nbsp; val s = <a href="../fetcher/status/statusapiv1.scala.html#L201" title="fetcher/status/statusapiv1.scala:201">errorMessage</a>.split(&quot;\\r\\<a href="../utils/AggregatePerfValue.scala.html#L28" title="utils/AggregatePerfValue.scala:28">n</a>|\\<a href="../utils/AggregatePerfValue.scala.html#L28" title="utils/AggregatePerfValue.scala:28">n</a>|\\r&quot;)<br/>
<br/>
&nbsp; &nbsp; if (s.length &lt;= 2) {<br/>
&nbsp; &nbsp; &nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L201" title="fetcher/status/statusapiv1.scala:201">errorMessage</a><br/>
&nbsp; &nbsp; } else {<br/>
&nbsp; &nbsp; &nbsp; s(1)<br/>
&nbsp; &nbsp; }<br/>
&nbsp; }<br/>
<br/>
<a id="L529">&#x200c;</a>&nbsp; private def <span class="linkable">getTargetHost</span>(<a href="../fetcher/status/statusapiv1.scala.html#L201" title="fetcher/status/statusapiv1.scala:201">errorMessage</a>: String): Option[String] = {<br/>
&nbsp; &nbsp; val s = &quot;Failed to connect to &quot;<br/>
&nbsp; &nbsp; val <a href="../fetcher/status/statusapiv1.scala.html#L192" title="fetcher/status/statusapiv1.scala:192">index</a> = <a href="../fetcher/status/statusapiv1.scala.html#L201" title="fetcher/status/statusapiv1.scala:201">errorMessage</a>.indexOf(s)<br/>
&nbsp; &nbsp; if (<a href="../fetcher/status/statusapiv1.scala.html#L192" title="fetcher/status/statusapiv1.scala:192">index</a> == -1) {<br/>
&nbsp; &nbsp; &nbsp; None<br/>
&nbsp; &nbsp; } else {<br/>
&nbsp; &nbsp; &nbsp; val slashIndex = <a href="../fetcher/status/statusapiv1.scala.html#L201" title="fetcher/status/statusapiv1.scala:201">errorMessage</a>.indexOf(&quot;/&quot;, <a href="../fetcher/status/statusapiv1.scala.html#L192" title="fetcher/status/statusapiv1.scala:192">index</a>)<br/>
&nbsp; &nbsp; &nbsp; Some(<a href="../fetcher/status/statusapiv1.scala.html#L201" title="fetcher/status/statusapiv1.scala:201">errorMessage</a>.substring(<a href="../fetcher/status/statusapiv1.scala.html#L192" title="fetcher/status/statusapiv1.scala:192">index</a> + s.length, slashIndex))<br/>
&nbsp; &nbsp; }<br/>
&nbsp; }<br/>
<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Check the <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a> for <a href="../fetcher/status/statusapiv1.scala.html#L180" title="fetcher/status/statusapiv1.scala:180">tasks</a> that failed for a specified error.<br/>
&nbsp;&nbsp; *<br/>
&nbsp;&nbsp; * @param <a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a>&nbsp; &nbsp; &nbsp; <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a> ID.<br/>
&nbsp;&nbsp; * @param stageData&nbsp; &nbsp; <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a> data.<br/>
&nbsp;&nbsp; * @param <a href="../fetcher/status/statusapiv1.scala.html#L68" title="fetcher/status/statusapiv1.scala:68">failedTasks</a>&nbsp; list of failed <a href="../fetcher/status/statusapiv1.scala.html#L180" title="fetcher/status/statusapiv1.scala:180">tasks</a>.<br/>
&nbsp;&nbsp; * @param taskError&nbsp; &nbsp; the error to check for.<br/>
&nbsp;&nbsp; * @param <a href="../fetcher/status/statusapiv1.scala.html#L201" title="fetcher/status/statusapiv1.scala:201">errorMessage</a> the message/explanation to print if the the specified error is found.<br/>
&nbsp;&nbsp; * @param <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a>&nbsp; &nbsp; &nbsp; information and recommendations -- any new recommendations<br/>
&nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; from analyzing the <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a> for errors causing <a href="../fetcher/status/statusapiv1.scala.html#L180" title="fetcher/status/statusapiv1.scala:180">tasks</a> to fail will be appended.<br/>
&nbsp;&nbsp; * @return<br/>
&nbsp;&nbsp; */<br/>
<a id="L553">&#x200c;</a>&nbsp; private def <span class="linkable">checkForSpecificTaskError</span>(<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a>: Int,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stageData: <a href="../fetcher/status/statusapiv1.scala.html#L148" title="fetcher/status/statusapiv1.scala:148">StageData</a>,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L68" title="fetcher/status/statusapiv1.scala:68">failedTasks</a>: Iterable[<a href="../fetcher/status/statusapiv1.scala.html#L190" title="fetcher/status/statusapiv1.scala:190">TaskData</a>],<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; taskError: String,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L201" title="fetcher/status/statusapiv1.scala:201">errorMessage</a>: String,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a>: ArrayBuffer[String]): (Int, Severity) = {<br/>
&nbsp; &nbsp; val numTasksWithError = <a href="#L576" title="heuristics/StageAnalyzer.scala:576">getNumTasksWithError</a>(<a href="../fetcher/status/statusapiv1.scala.html#L68" title="fetcher/status/statusapiv1.scala:68">failedTasks</a>, taskError)<br/>
&nbsp; &nbsp; if (numTasksWithError &gt; 0) {<br/>
&nbsp; &nbsp; &nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a> += s&quot;Stage $<a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a> has $numTasksWithError <a href="../fetcher/status/statusapiv1.scala.html#L180" title="fetcher/status/statusapiv1.scala:180">tasks</a> that failed because &quot; +<br/>
&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L201" title="fetcher/status/statusapiv1.scala:201">errorMessage</a><br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; val severity = taskFailureRateSeverityThresholds.<a href="SeverityThresholds.scala.html#L33" title="heuristics/SeverityThresholds.scala:33">severityOf</a>(numTasksWithError.toDouble / stageData.<a href="../fetcher/status/statusapiv1.scala.html#L112" title="fetcher/status/statusapiv1.scala:112">numTasks</a>)<br/>
&nbsp; &nbsp; (numTasksWithError, severity)<br/>
&nbsp; }<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Get the number of <a href="../fetcher/status/statusapiv1.scala.html#L180" title="fetcher/status/statusapiv1.scala:180">tasks</a> that failed with the specified error, using a simple string search.<br/>
&nbsp;&nbsp; *<br/>
&nbsp;&nbsp; * @param <a href="../fetcher/status/statusapiv1.scala.html#L180" title="fetcher/status/statusapiv1.scala:180">tasks</a> list of failed <a href="../fetcher/status/statusapiv1.scala.html#L180" title="fetcher/status/statusapiv1.scala:180">tasks</a>.<br/>
&nbsp;&nbsp; * @param error error to look for.<br/>
&nbsp;&nbsp; * @return number of failed <a href="../fetcher/status/statusapiv1.scala.html#L180" title="fetcher/status/statusapiv1.scala:180">tasks</a> wit the specified error.<br/>
&nbsp;&nbsp; */<br/>
<a id="L576">&#x200c;</a>&nbsp; private def <span class="linkable">getNumTasksWithError</span>(<a href="../fetcher/status/statusapiv1.scala.html#L180" title="fetcher/status/statusapiv1.scala:180">tasks</a>: Iterable[<a href="../fetcher/status/statusapiv1.scala.html#L190" title="fetcher/status/statusapiv1.scala:190">TaskData</a>], error: String): Int = {<br/>
&nbsp; &nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L180" title="fetcher/status/statusapiv1.scala:180">tasks</a>.count(task =&gt; task.<a href="../fetcher/status/statusapiv1.scala.html#L201" title="fetcher/status/statusapiv1.scala:201">errorMessage</a>.contains(error))<br/>
&nbsp; }<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Check the <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a> for a high ratio of time spent in GC compared to task run time.<br/>
&nbsp;&nbsp; *<br/>
&nbsp;&nbsp; * @param <a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a>&nbsp;&nbsp; <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a> ID.<br/>
&nbsp;&nbsp; * @param stageData <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a> data.<br/>
&nbsp;&nbsp; * @return result of GC analysis for the <a href="../utils/spark/PerStageReport.scala.html#L26" title="utils/spark/PerStageReport.scala:26">stage</a>.<br/>
&nbsp;&nbsp; */<br/>
<a id="L587">&#x200c;</a>&nbsp; private def <span class="linkable">checkForGC</span>(<a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a>: Int, stageData: <a href="../fetcher/status/statusapiv1.scala.html#L148" title="fetcher/status/statusapiv1.scala:148">StageData</a>): Option[<a href="#L43" title="heuristics/StageAnalyzer.scala:43">SimpleStageAnalysisResult</a>] = {<br/>
&nbsp; &nbsp; var gcTime = 0.0D<br/>
&nbsp; &nbsp; var <a href="../fetcher/status/statusapiv1.scala.html#L67" title="fetcher/status/statusapiv1.scala:67">taskTime</a> = 0.0D<br/>
&nbsp; &nbsp; val severity = stageData.<a href="../fetcher/status/statusapiv1.scala.html#L187" title="fetcher/status/statusapiv1.scala:187">taskSummary</a>.map { task =&gt;<br/>
&nbsp; &nbsp; &nbsp; gcTime = task.<a href="../fetcher/status/statusapiv1.scala.html#L208" title="fetcher/status/statusapiv1.scala:208">jvmGcTime</a>(DISTRIBUTION_MEDIAN_IDX)<br/>
&nbsp; &nbsp; &nbsp; <a href="../fetcher/status/statusapiv1.scala.html#L67" title="fetcher/status/statusapiv1.scala:67">taskTime</a> = task.<a href="../fetcher/status/statusapiv1.scala.html#L157" title="fetcher/status/statusapiv1.scala:157">executorRunTime</a>(DISTRIBUTION_MEDIAN_IDX)<br/>
&nbsp; &nbsp; &nbsp; DEFAULT_GC_SEVERITY_A_THRESHOLDS.<a href="SeverityThresholds.scala.html#L33" title="heuristics/SeverityThresholds.scala:33">severityOf</a>(gcTime / <a href="../fetcher/status/statusapiv1.scala.html#L67" title="fetcher/status/statusapiv1.scala:67">taskTime</a>)<br/>
&nbsp; &nbsp; }.getOrElse(Severity.NONE)<br/>
<br/>
&nbsp; &nbsp; val <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a> = if (<a href="#L431" title="heuristics/StageAnalyzer.scala:431">hasSignificantSeverity</a>(severity)) {<br/>
&nbsp; &nbsp; &nbsp; Seq(s&quot;Stage ${<a href="../fetcher/status/statusapiv1.scala.html#L150" title="fetcher/status/statusapiv1.scala:150">stageId</a>}: <a href="../fetcher/status/statusapiv1.scala.html#L180" title="fetcher/status/statusapiv1.scala:180">tasks</a> are spending significant time in GC (median task GC time is &quot; +<br/>
&nbsp; &nbsp; &nbsp; &nbsp; s&quot;${Utils.getDuration(gcTime.toLong)}, median task runtime is &quot; +<br/>
&nbsp; &nbsp; &nbsp; &nbsp; s&quot;${Utils.getDuration(gcTime.toLong)}&quot;)<br/>
&nbsp; &nbsp; } else {<br/>
&nbsp; &nbsp; &nbsp; Seq.empty<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; if (<a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a>.nonEmpty) {<br/>
&nbsp; &nbsp; &nbsp; Some(<a href="#L43" title="heuristics/StageAnalyzer.scala:43">SimpleStageAnalysisResult</a>(&quot;GC&quot;, stageData, <a href="../fetcher/status/statusapiv1.scala.html#L176" title="fetcher/status/statusapiv1.scala:176">details</a>))<br/>
&nbsp; &nbsp; } else {<br/>
&nbsp; &nbsp; &nbsp; None<br/>
&nbsp; &nbsp; }<br/>
&nbsp; }<br/>
}<br/>
</code>

 </body>
</html>
