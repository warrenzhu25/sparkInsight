<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>util/Utils.java - Spark Insight</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}


  </style>
 </head>
 <body>

  <h1>util/Utils.java - Spark Insight</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L46">Utils</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L259">MBSecondsToGBHours</a></li>
<li><a href="#L53">Utils</a></li>
<li><a href="#L483">byteStringAs</a></li>
<li><a href="#L475">byteStringAsGb</a></li>
<li><a href="#L465">byteStringAsMb</a></li>
<li><a href="#L164">commaSeparated</a></li>
<li><a href="#L377">formatStringOrNull</a></li>
<li><a href="#L88">getApplicationIdFromJobId</a></li>
<li><a href="#L392">getConfigurationParameters</a></li>
<li><a href="#L243">getDuration</a></li>
<li><a href="#L189">getHeuristicScore</a></li>
<li><a href="#L78">getJobIdFromApplicationId</a></li>
<li><a href="#L455">getNextTopOfTheDayTimestamp</a></li>
<li><a href="#L329">getNonNegativeInt</a></li>
<li><a href="#L355">getNonNegativeLong</a></li>
<li><a href="#L127">getParam</a></li>
<li><a href="#L292">getPercentage</a></li>
<li><a href="#L269">getResourceInGBHours</a></li>
<li><a href="#L443">getTopOfTheDayTimestamp</a></li>
<li><a href="#L314">isSet</a></li>
<li><a href="#L204">parseCsKeyValue</a></li>
<li><a href="#L98">parseJavaOptions</a></li>
<li><a href="#L411">sortJsonArray</a></li>
<li><a href="#L229">truncateField</a></li>
</ul>
 <h2>Source code</h2>

  <code>/*<br/>
 * Copyright 2016 LinkedIn Corp.<br/>
 *<br/>
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not<br/>
 * use this file except in compliance with the License. You may obtain a copy of<br/>
 * the License at<br/>
 *<br/>
 * http://www.apache.org/licenses/LICENSE-2.0<br/>
 *<br/>
 * Unless required by applicable law or agreed to in writing, software<br/>
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT<br/>
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the<br/>
 * License for the specific language governing permissions and limitations under<br/>
 * the License.<br/>
 */<br/>
<br/>
package com.microsoft.spark.insight.util;<br/>
<br/>
import com.google.common.collect.ImmutableMap;<br/>
import com.google.gson.JsonArray;<br/>
import com.google.gson.JsonElement;<br/>
import com.google.gson.JsonObject;<br/>
import com.microsoft.spark.insight.heuristics.<a href="../heuristics/Severity.java.html#L22" title="heuristics/Severity.java:22">Severity</a>;<br/>
import com.microsoft.spark.insight.math.<a href="../math/Statistics.java.html#L26" title="math/Statistics.java:26">Statistics</a>;<br/>
import org.apache.commons.io.FileUtils;<br/>
import org.apache.hadoop.conf.Configuration;<br/>
import org.apache.log4j.Logger;<br/>
import org.apache.spark.network.util.ByteUnit;<br/>
import org.w3c.dom.Element;<br/>
import org.w3c.dom.Node;<br/>
import org.w3c.dom.NodeList;<br/>
<br/>
import javax.script.ScriptEngine;<br/>
import javax.script.ScriptEngineManager;<br/>
import javax.script.ScriptException;<br/>
import java.text.DecimalFormat;<br/>
import java.util.*;<br/>
import java.util.concurrent.TimeUnit;<br/>
import java.util.regex.Matcher;<br/>
import java.util.regex.Pattern;<br/>
<br/>
<br/>
/**<br/>
 * This class contains all the utility methods.<br/>
 */<br/>
<a id="L46">&#x200c;</a>public final class <span class="linkable">Utils</span> {<br/>
&nbsp; private static final Logger logger = Logger.getLogger(<a href="#L46" title="util/Utils.java:46">Utils</a>.class);<br/>
<br/>
&nbsp; private static final String TRUNCATE_SUFFIX = &quot;...&quot;;<br/>
&nbsp; /** Milliseconds in one day. */<br/>
&nbsp; private static final long MILLIS_ONE_DAY = 86400000L;<br/>
<br/>
<a id="L53">&#x200c;</a>&nbsp; private <span class="linkable">Utils</span>() {<br/>
&nbsp; &nbsp; // do nothing<br/>
&nbsp; }<br/>
<br/>
&nbsp; private static final ImmutableMap&lt;String, ByteUnit&gt; byteSuffixes =<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ImmutableMap.&lt;String, ByteUnit&gt;builder()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .put(&quot;b&quot;, ByteUnit.BYTE)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .put(&quot;k&quot;, ByteUnit.KiB)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .put(&quot;kb&quot;, ByteUnit.KiB)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .put(&quot;m&quot;, ByteUnit.MiB)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .put(&quot;mb&quot;, ByteUnit.MiB)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .put(&quot;g&quot;, ByteUnit.GiB)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .put(&quot;gb&quot;, ByteUnit.GiB)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .put(&quot;t&quot;, ByteUnit.TiB)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .put(&quot;tb&quot;, ByteUnit.TiB)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .put(&quot;p&quot;, ByteUnit.PiB)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .put(&quot;pb&quot;, ByteUnit.PiB)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .build();<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Given a mapreduce job's application id, get its corresponding job id<br/>
&nbsp;&nbsp; *<br/>
&nbsp;&nbsp; * @param appId The application id of the job<br/>
&nbsp;&nbsp; * @return the corresponding job id<br/>
&nbsp;&nbsp; */<br/>
<a id="L78">&#x200c;</a>&nbsp; public static String <span class="linkable">getJobIdFromApplicationId</span>(String appId) {<br/>
&nbsp; &nbsp; return appId.replaceAll(&quot;application&quot;, &quot;job&quot;);<br/>
&nbsp; }<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Given a mapreduce job's job id, get its corresponding YARN application id.<br/>
&nbsp;&nbsp; *<br/>
&nbsp;&nbsp; * @param jobId The job id of the job<br/>
&nbsp;&nbsp; * @return the corresponding application id<br/>
&nbsp;&nbsp; */<br/>
<a id="L88">&#x200c;</a>&nbsp; public static String <span class="linkable">getApplicationIdFromJobId</span>(String jobId) {<br/>
&nbsp; &nbsp; return jobId.replaceAll(&quot;job&quot;, &quot;application&quot;);<br/>
&nbsp; }<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Parse a java option string in the format of &quot;-Dfoo=bar -Dfoo2=bar ...&quot; into a {optionName -&gt; optionValue} map.<br/>
&nbsp;&nbsp; *<br/>
&nbsp;&nbsp; * @param str The option string to parse<br/>
&nbsp;&nbsp; * @return A map of options<br/>
&nbsp;&nbsp; */<br/>
<a id="L98">&#x200c;</a>&nbsp; public static Map&lt;String, String&gt; <span class="linkable">parseJavaOptions</span>(String str) {<br/>
&nbsp; &nbsp; Map&lt;String, String&gt; options = new HashMap&lt;String, String&gt;();<br/>
&nbsp; &nbsp; String[] tokens = str.trim().split(&quot;\\s&quot;);<br/>
&nbsp; &nbsp; for (String token : tokens) {<br/>
&nbsp; &nbsp; &nbsp; if (token.isEmpty() || token.startsWith(&quot;-X&quot;)) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; continue;<br/>
&nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; if (!token.startsWith(&quot;-D&quot;)) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; throw new IllegalArgumentException(<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;Cannot parse java option string [&quot; + str + &quot;]. Some options does not begin with -D prefix.&quot;);<br/>
&nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; String[] parts = token.substring(2).split(&quot;=&quot;, 2);<br/>
&nbsp; &nbsp; &nbsp; if (parts.length != 2) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; throw new IllegalArgumentException(<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;Cannot parse java option string [&quot; + str + &quot;]. The part [&quot; + token + &quot;] does not contain a =.&quot;);<br/>
&nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; options.put(parts[0], parts[1]);<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; return options;<br/>
&nbsp; }<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Returns the configured thresholds after evaluating and verifying the levels.<br/>
&nbsp;&nbsp; *<br/>
&nbsp;&nbsp; * @param rawLimits A comma separated string of threshold limits<br/>
&nbsp;&nbsp; * @param thresholdLevels The number of threshold levels<br/>
&nbsp;&nbsp; * @return The evaluated threshold limits<br/>
&nbsp;&nbsp; */<br/>
<a id="L127">&#x200c;</a>&nbsp; public static double[] <span class="linkable">getParam</span>(String rawLimits, int thresholdLevels) {<br/>
&nbsp; &nbsp; double[] parsedLimits = null;<br/>
<br/>
&nbsp; &nbsp; if (rawLimits != null &amp;&amp; !rawLimits.isEmpty()) {<br/>
&nbsp; &nbsp; &nbsp; String[] thresholds = rawLimits.split(&quot;,&quot;);<br/>
&nbsp; &nbsp; &nbsp; if (thresholds.length != thresholdLevels) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; logger.error(&quot;Could not find &quot; + thresholdLevels + &quot; threshold levels in &quot; + rawLimits);<br/>
&nbsp; &nbsp; &nbsp; &nbsp; parsedLimits = null;<br/>
&nbsp; &nbsp; &nbsp; } else {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; // Evaluate the limits<br/>
&nbsp; &nbsp; &nbsp; &nbsp; parsedLimits = new double[thresholdLevels];<br/>
&nbsp; &nbsp; &nbsp; &nbsp; ScriptEngineManager mgr = new ScriptEngineManager(null);<br/>
&nbsp; &nbsp; &nbsp; &nbsp; ScriptEngine engine = mgr.getEngineByName(&quot;JavaScript&quot;);<br/>
&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; thresholdLevels; i++) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsedLimits[i] = Double.parseDouble(engine.eval(thresholds[i]).<a href="MemoryFormatUtils.java.html#L52" title="util/MemoryFormatUtils.java:52">toString</a>());<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } catch (ScriptException e) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; logger.error(&quot;Could not evaluate &quot; + thresholds[i] + &quot; in &quot; + rawLimits);<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsedLimits = null;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; return parsedLimits;<br/>
&nbsp; }<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Combine the parts into a comma separated String<br/>
&nbsp;&nbsp; *<br/>
&nbsp;&nbsp; * Example:<br/>
&nbsp;&nbsp; * input: part1 = &quot;foo&quot; and part2 = &quot;bar&quot;<br/>
&nbsp;&nbsp; * output = &quot;foo,bar&quot;<br/>
&nbsp;&nbsp; *<br/>
&nbsp;&nbsp; * @param parts The parts to combine<br/>
&nbsp;&nbsp; * @return The comma separated string<br/>
&nbsp;&nbsp; */<br/>
<a id="L164">&#x200c;</a>&nbsp; public static String <span class="linkable">commaSeparated</span>(String... parts) {<br/>
&nbsp; &nbsp; StringBuilder sb = new StringBuilder();<br/>
&nbsp; &nbsp; String comma = &quot;,&quot;;<br/>
&nbsp; &nbsp; if (parts.length != 0) {<br/>
&nbsp; &nbsp; &nbsp; sb.append(parts[0]);<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; for (int i = 1; i &lt; parts.length; i++) {<br/>
&nbsp; &nbsp; &nbsp; if (parts[i] != null &amp;&amp; !parts[i].isEmpty()) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; sb.append(comma);<br/>
&nbsp; &nbsp; &nbsp; &nbsp; sb.append(parts[i]);<br/>
&nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; return sb.<a href="MemoryFormatUtils.java.html#L52" title="util/MemoryFormatUtils.java:52">toString</a>();<br/>
&nbsp; }<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Compute the score for the heuristic based on the number of tasks and severity.<br/>
&nbsp;&nbsp; * This is applicable only to mapreduce applications.<br/>
&nbsp;&nbsp; *<br/>
&nbsp;&nbsp; * Score = severity * num of tasks (where severity NOT in [NONE, LOW])<br/>
&nbsp;&nbsp; *<br/>
&nbsp;&nbsp; * @param severity The heuristic severity<br/>
&nbsp;&nbsp; * @param tasks The number of tasks (map/reduce)<br/>
&nbsp;&nbsp; * @return<br/>
&nbsp;&nbsp; */<br/>
<a id="L189">&#x200c;</a>&nbsp; public static int <span class="linkable">getHeuristicScore</span>(<a href="../heuristics/Severity.java.html#L22" title="heuristics/Severity.java:22">Severity</a> severity, int tasks) {<br/>
&nbsp; &nbsp; int score = 0;<br/>
&nbsp; &nbsp; if (severity != <a href="../heuristics/Severity.java.html#L22" title="heuristics/Severity.java:22">Severity</a>.NONE &amp;&amp; severity != <a href="../heuristics/Severity.java.html#L22" title="heuristics/Severity.java:22">Severity</a>.LOW) {<br/>
&nbsp; &nbsp; &nbsp; score = severity.<a href="../heuristics/Severity.java.html#L53" title="heuristics/Severity.java:53">getValue</a>() * tasks;<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; return score;<br/>
&nbsp; }<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Parse a comma separated string of key-value pairs into a {property -&gt; value} Map.<br/>
&nbsp;&nbsp; * e.g. string format: &quot;foo1=bar1,foo2=bar2,foo3=bar3...&quot;<br/>
&nbsp;&nbsp; *<br/>
&nbsp;&nbsp; * @param str The comma separated, key-value pair string to parse<br/>
&nbsp;&nbsp; * @return A map of properties<br/>
&nbsp;&nbsp; */<br/>
<a id="L204">&#x200c;</a>&nbsp; public static Map&lt;String, String&gt; <span class="linkable">parseCsKeyValue</span>(String str) {<br/>
&nbsp; &nbsp; Map&lt;String, String&gt; properties = new HashMap&lt;String, String&gt;();<br/>
&nbsp; &nbsp; String[] tokens = null;<br/>
&nbsp; &nbsp; if (str != null) {<br/>
&nbsp; &nbsp; &nbsp; tokens = str.trim().split(&quot;,&quot;);<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; for (String token : tokens) {<br/>
&nbsp; &nbsp; &nbsp; if (!token.isEmpty()) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; String[] parts = token.split(&quot;=&quot;, 2);<br/>
&nbsp; &nbsp; &nbsp; &nbsp; if (parts.length == 2) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; properties.put(parts[0], parts[1]);<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; return properties;<br/>
&nbsp; }<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Truncate the field by the specified limit<br/>
&nbsp;&nbsp; *<br/>
&nbsp;&nbsp; * @param field the field to br truncated<br/>
&nbsp;&nbsp; * @param limit the truncation limit<br/>
&nbsp;&nbsp; * @param context additional context for logging purposes<br/>
&nbsp;&nbsp; * @return The truncated field<br/>
&nbsp;&nbsp; */<br/>
<a id="L229">&#x200c;</a>&nbsp; public static String <span class="linkable">truncateField</span>(String field, int limit, String context) {<br/>
&nbsp; &nbsp; if (field != null &amp;&amp; limit &gt; TRUNCATE_SUFFIX.length() &amp;&amp; field.length() &gt; limit) {<br/>
&nbsp; &nbsp; &nbsp; logger.info(&quot;Truncating &quot; + field + &quot; to &quot; + limit + &quot; characters for &quot; + context);<br/>
&nbsp; &nbsp; &nbsp; field = field.substring(0, limit - 3) + &quot;...&quot;;<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; return field;<br/>
&nbsp; }<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Convert a millisecond duration to a string format<br/>
&nbsp;&nbsp; *<br/>
&nbsp;&nbsp; * @param millis A duration to convert to a string form<br/>
&nbsp;&nbsp; * @return A string of the form &quot;X:Y:Z Hours&quot;.<br/>
&nbsp;&nbsp; */<br/>
<a id="L243">&#x200c;</a>&nbsp; public static String <span class="linkable">getDuration</span>(long millis) {<br/>
<br/>
&nbsp; &nbsp; long hours = TimeUnit.MILLISECONDS.toHours(millis);<br/>
&nbsp; &nbsp; millis -= TimeUnit.HOURS.toMillis(hours);<br/>
&nbsp; &nbsp; long minutes = TimeUnit.MILLISECONDS.toMinutes(millis);<br/>
&nbsp; &nbsp; millis -= TimeUnit.MINUTES.toMillis(minutes);<br/>
&nbsp; &nbsp; long seconds = TimeUnit.MILLISECONDS.toSeconds(millis);<br/>
<br/>
&nbsp; &nbsp; return String.format(&quot;%d:%02d:%02d&quot;, hours, minutes, seconds);<br/>
&nbsp; }<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Convert a value in MBSeconds to GBHours<br/>
&nbsp;&nbsp; * @param MBSeconds The value to convert<br/>
&nbsp;&nbsp; * @return A double of the value in GB Hours unit<br/>
&nbsp;&nbsp; */<br/>
<a id="L259">&#x200c;</a>&nbsp; public static double <span class="linkable">MBSecondsToGBHours</span>(long MBSeconds) {<br/>
&nbsp; &nbsp; double GBseconds = (double) MBSeconds / (double) FileUtils.ONE_KB;<br/>
&nbsp; &nbsp; double GBHours = GBseconds / <a href="../math/Statistics.java.html#L26" title="math/Statistics.java:26">Statistics</a>.HOUR;<br/>
&nbsp; &nbsp; return GBHours;<br/>
&nbsp; }<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Convert a value in MBSeconds to GBHours<br/>
&nbsp;&nbsp; * @param MBSeconds The value to convert<br/>
&nbsp;&nbsp; * @return A string of form a.xyz GB Hours<br/>
&nbsp;&nbsp; */<br/>
<a id="L269">&#x200c;</a>&nbsp; public static String <span class="linkable">getResourceInGBHours</span>(long MBSeconds) {<br/>
<br/>
&nbsp; &nbsp; if (MBSeconds == 0) {<br/>
&nbsp; &nbsp; &nbsp; return &quot;0 GB Hours&quot;;<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; double GBHours = <a href="#L259" title="util/Utils.java:259">MBSecondsToGBHours</a>(MBSeconds);<br/>
&nbsp; &nbsp; if ((long) (GBHours * 1000) == 0) {<br/>
&nbsp; &nbsp; &nbsp; return &quot;0 GB Hours&quot;;<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; DecimalFormat df = new DecimalFormat(&quot;0.000&quot;);<br/>
&nbsp; &nbsp; String GBHoursString = df.format(GBHours);<br/>
&nbsp; &nbsp; GBHoursString = GBHoursString + &quot; GB Hours&quot;;<br/>
&nbsp; &nbsp; return GBHoursString;<br/>
&nbsp; }<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Find percentage of numerator of denominator<br/>
&nbsp;&nbsp; * @param numerator The numerator<br/>
&nbsp;&nbsp; * @param denominator The denominator<br/>
&nbsp;&nbsp; * @return The percentage string of the form `x.yz %`<br/>
&nbsp;&nbsp; */<br/>
<a id="L292">&#x200c;</a>&nbsp; public static String <span class="linkable">getPercentage</span>(long numerator, long denominator) {<br/>
<br/>
&nbsp; &nbsp; if (denominator == 0) {<br/>
&nbsp; &nbsp; &nbsp; return &quot;NaN&quot;;<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; double percentage = ((double) numerator / (double) denominator) * 100;<br/>
<br/>
&nbsp; &nbsp; if ((long) (percentage) == 0) {<br/>
&nbsp; &nbsp; &nbsp; return &quot;0 %&quot;;<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; DecimalFormat df = new DecimalFormat(&quot;0.00&quot;);<br/>
&nbsp; &nbsp; return df.format(percentage).concat(&quot; %&quot;);<br/>
&nbsp; }<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Checks if the property is set<br/>
&nbsp;&nbsp; *<br/>
&nbsp;&nbsp; * @param property The property to tbe checked.<br/>
&nbsp;&nbsp; * @return true if set, false otherwise<br/>
&nbsp;&nbsp; */<br/>
<a id="L314">&#x200c;</a>&nbsp; public static boolean <span class="linkable">isSet</span>(String property) {<br/>
&nbsp; &nbsp; return property != null &amp;&amp; !property.isEmpty();<br/>
&nbsp; }<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Get non negative int value from Configuration.<br/>
&nbsp;&nbsp; *<br/>
&nbsp;&nbsp; * If the value is not set or not an integer, the provided default value is returned.<br/>
&nbsp;&nbsp; * If the value is negative, 0 is returned.<br/>
&nbsp;&nbsp; *<br/>
&nbsp;&nbsp; * @param conf Configuration to be extracted<br/>
&nbsp;&nbsp; * @param key property name<br/>
&nbsp;&nbsp; * @param defaultValue default value<br/>
&nbsp;&nbsp; * @return non negative int value<br/>
&nbsp;&nbsp; */<br/>
<a id="L329">&#x200c;</a>&nbsp; public static int <span class="linkable">getNonNegativeInt</span>(Configuration conf, String key, int defaultValue) {<br/>
&nbsp; &nbsp; try {<br/>
&nbsp; &nbsp; &nbsp; int value = conf.getInt(key, defaultValue);<br/>
&nbsp; &nbsp; &nbsp; if (value &lt; 0) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; value = 0;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; logger.warn(&quot;Configuration &quot; + key + &quot; is negative. Resetting it to 0&quot;);<br/>
&nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; return value;<br/>
&nbsp; &nbsp; } catch (NumberFormatException e) {<br/>
&nbsp; &nbsp; &nbsp; logger.error(&quot;Invalid configuration &quot; + key + &quot;. Value is &quot; + conf.get(key)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + &quot;. Resetting it to default value: &quot; + defaultValue);<br/>
&nbsp; &nbsp; &nbsp; return defaultValue;<br/>
&nbsp; &nbsp; }<br/>
&nbsp; }<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Get non negative long value from Configuration.<br/>
&nbsp;&nbsp; *<br/>
&nbsp;&nbsp; * If the value is not set or not a long, the provided default value is returned.<br/>
&nbsp;&nbsp; * If the value is negative, 0 is returned.<br/>
&nbsp;&nbsp; *<br/>
&nbsp;&nbsp; * @param conf Configuration to be extracted<br/>
&nbsp;&nbsp; * @param key property name<br/>
&nbsp;&nbsp; * @param defaultValue default value<br/>
&nbsp;&nbsp; * @return non negative long value<br/>
&nbsp;&nbsp; */<br/>
<a id="L355">&#x200c;</a>&nbsp; public static long <span class="linkable">getNonNegativeLong</span>(Configuration conf, String key, long defaultValue) {<br/>
&nbsp; &nbsp; try {<br/>
&nbsp; &nbsp; &nbsp; long value = conf.getLong(key, defaultValue);<br/>
&nbsp; &nbsp; &nbsp; if (value &lt; 0) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; value = 0;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; logger.warn(&quot;Configuration &quot; + key + &quot; is negative. Resetting it to 0&quot;);<br/>
&nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; return value;<br/>
&nbsp; &nbsp; } catch (NumberFormatException e) {<br/>
&nbsp; &nbsp; &nbsp; logger.error(&quot;Invalid configuration &quot; + key + &quot;. Value is &quot; + conf.get(key)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + &quot;. Resetting it to default value: &quot; + defaultValue);<br/>
&nbsp; &nbsp; &nbsp; return defaultValue;<br/>
&nbsp; &nbsp; }<br/>
&nbsp; }<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Return the formatted string unless one of the args is null in which case null is returned<br/>
&nbsp;&nbsp; *<br/>
&nbsp;&nbsp; * @param formatString the standard Java format string<br/>
&nbsp;&nbsp; * @param args objects to put in the format string<br/>
&nbsp;&nbsp; * @return formatted String or null<br/>
&nbsp;&nbsp; */<br/>
<a id="L377">&#x200c;</a>&nbsp; public static String <span class="linkable">formatStringOrNull</span>(String formatString, Object... args) {<br/>
&nbsp; &nbsp; for (Object o : args) {<br/>
&nbsp; &nbsp; &nbsp; if (o == null) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; return null;<br/>
&nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; return String.format(formatString, args);<br/>
&nbsp; }<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Given a configuration element, extract the params map.<br/>
&nbsp;&nbsp; *<br/>
&nbsp;&nbsp; * @param confElem the configuration element<br/>
&nbsp;&nbsp; * @return the params map or an empty map if one can't be found<br/>
&nbsp;&nbsp; */<br/>
<a id="L392">&#x200c;</a>&nbsp; public static Map&lt;String, String&gt; <span class="linkable">getConfigurationParameters</span>(Element confElem) {<br/>
&nbsp; &nbsp; Map&lt;String, String&gt; paramsMap = new HashMap&lt;String, String&gt;();<br/>
&nbsp; &nbsp; Node paramsNode = confElem.getElementsByTagName(&quot;params&quot;).item(0);<br/>
&nbsp; &nbsp; if (paramsNode != null) {<br/>
&nbsp; &nbsp; &nbsp; NodeList paramsList = paramsNode.getChildNodes();<br/>
&nbsp; &nbsp; &nbsp; for (int j = 0; j &lt; paramsList.getLength(); j++) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Node paramNode = paramsList.item(j);<br/>
&nbsp; &nbsp; &nbsp; &nbsp; if (paramNode != null &amp;&amp; !paramsMap.containsKey(paramNode.getNodeName())) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramsMap.put(paramNode.getNodeName(), paramNode.getTextContent());<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; return paramsMap;<br/>
&nbsp; }<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Sort the JsonArray given in parameters, based on the flowtime property,<br/>
&nbsp;&nbsp; * from the most recent to the oldest.<br/>
&nbsp;&nbsp; */<br/>
<a id="L411">&#x200c;</a>&nbsp; public static JsonArray <span class="linkable">sortJsonArray</span>(JsonArray datasets) {<br/>
&nbsp; &nbsp; ArrayList&lt;JsonObject&gt; datasetsList = new ArrayList&lt;JsonObject&gt;();<br/>
&nbsp; &nbsp; for (JsonElement element : datasets) {<br/>
&nbsp; &nbsp; &nbsp; datasetsList.add(element.getAsJsonObject());<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; Collections.sort( datasetsList, new Comparator&lt;JsonObject&gt;() {<br/>
&nbsp; &nbsp; &nbsp; private String KEY_NAME = &quot;flowtime&quot;;<br/>
<br/>
&nbsp; &nbsp; &nbsp; @Override<br/>
&nbsp; &nbsp; &nbsp; public int compare(JsonObject a, JsonObject b) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Long valA = a.get(KEY_NAME).getAsLong();<br/>
&nbsp; &nbsp; &nbsp; &nbsp; Long valB = b.get(KEY_NAME).getAsLong();<br/>
&nbsp; &nbsp; &nbsp; &nbsp; return valA.compareTo(valB);<br/>
&nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; });<br/>
<br/>
&nbsp; &nbsp; datasets = new JsonArray();<br/>
&nbsp; &nbsp; for (JsonObject element : datasetsList) {<br/>
&nbsp; &nbsp; &nbsp; datasets.add(element);<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; return datasets;<br/>
&nbsp; }<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Returns the timestamp of that day's start timestamp (that is midnight 00:00:00 AM) for a given input timestamp.<br/>
&nbsp;&nbsp; * For instance, if the supplied timestamp is 100000, this method would return 86400, which corresponds to<br/>
&nbsp;&nbsp; * 2 January 1970, 00:00:00 GMT.<br/>
&nbsp;&nbsp; *<br/>
&nbsp;&nbsp; * @param ts Timestamp for which top of the day timestamp is to be found.<br/>
&nbsp;&nbsp; * @return Timestamp of that day's beginning (midnight)<br/>
&nbsp;&nbsp; */<br/>
<a id="L443">&#x200c;</a>&nbsp; public static long <span class="linkable">getTopOfTheDayTimestamp</span>(long ts) {<br/>
&nbsp; &nbsp; return (ts - (ts % MILLIS_ONE_DAY));<br/>
&nbsp; }<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Returns the timestamp of next day's start timestamp (that is midnight 00:00:00 AM) for a given input timestamp.<br/>
&nbsp;&nbsp; * For instance, if the supplied timestamp is 100000, this method would return 172800, which corresponds to<br/>
&nbsp;&nbsp; * 3 January 1970, 00:00:00 GMT.<br/>
&nbsp;&nbsp; *<br/>
&nbsp;&nbsp; * @param ts Timestamp for which next top of the day timestamp is to be found.<br/>
&nbsp;&nbsp; * @return Timestamp of next day's beginning (midnight)<br/>
&nbsp;&nbsp; */<br/>
<a id="L455">&#x200c;</a>&nbsp; public static long <span class="linkable">getNextTopOfTheDayTimestamp</span>(long ts) {<br/>
&nbsp; &nbsp; return (<a href="#L443" title="util/Utils.java:443">getTopOfTheDayTimestamp</a>(ts) + MILLIS_ONE_DAY);<br/>
&nbsp; }<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Convert a passed byte string (e.g. 50b, 100k, or 250m) to mebibytes for<br/>
&nbsp;&nbsp; * internal use.<br/>
&nbsp;&nbsp; *<br/>
&nbsp;&nbsp; * If no suffix is provided, the passed number is assumed to be in mebibytes.<br/>
&nbsp;&nbsp; */<br/>
<a id="L465">&#x200c;</a>&nbsp; public static long <span class="linkable">byteStringAsMb</span>(String str) {<br/>
&nbsp; &nbsp; return <a href="#L483" title="util/Utils.java:483">byteStringAs</a>(str, ByteUnit.MiB);<br/>
&nbsp; }<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Convert a passed byte string (e.g. 50b, 100k, or 250m) to gibibytes for<br/>
&nbsp;&nbsp; * internal use.<br/>
&nbsp;&nbsp; *<br/>
&nbsp;&nbsp; * If no suffix is provided, the passed number is assumed to be in gibibytes.<br/>
&nbsp;&nbsp; */<br/>
<a id="L475">&#x200c;</a>&nbsp; public static long <span class="linkable">byteStringAsGb</span>(String str) {<br/>
&nbsp; &nbsp; return <a href="#L483" title="util/Utils.java:483">byteStringAs</a>(str, ByteUnit.GiB);<br/>
&nbsp; }<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Convert a passed byte string (e.g. 50b, 100kb, or 250mb) to the given. If no suffix is<br/>
&nbsp;&nbsp; * provided, a direct conversion to the provided unit is attempted.<br/>
&nbsp;&nbsp; */<br/>
<a id="L483">&#x200c;</a>&nbsp; public static long <span class="linkable">byteStringAs</span>(String str, ByteUnit unit) {<br/>
&nbsp; &nbsp; String lower = str.toLowerCase(Locale.ROOT).trim();<br/>
<br/>
&nbsp; &nbsp; try {<br/>
&nbsp; &nbsp; &nbsp; Matcher m = Pattern.compile(&quot;([0-9]+)([a-z]+)?&quot;).matcher(lower);<br/>
&nbsp; &nbsp; &nbsp; Matcher fractionMatcher = Pattern.compile(&quot;([0-9]+\\.[0-9]+)([a-z]+)?&quot;).matcher(lower);<br/>
<br/>
&nbsp; &nbsp; &nbsp; if (m.matches()) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; long val = Long.parseLong(m.group(1));<br/>
&nbsp; &nbsp; &nbsp; &nbsp; String suffix = m.group(2);<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; // Check for invalid suffixes<br/>
&nbsp; &nbsp; &nbsp; &nbsp; if (suffix != null &amp;&amp; !byteSuffixes.containsKey(suffix)) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new NumberFormatException(&quot;Invalid suffix: \&quot;&quot; + suffix + &quot;\&quot;&quot;);<br/>
&nbsp; &nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; // If suffix is valid use that, otherwise none was provided and use the default passed<br/>
&nbsp; &nbsp; &nbsp; &nbsp; return unit.convertFrom(val, suffix != null ? byteSuffixes.get(suffix) : unit);<br/>
&nbsp; &nbsp; &nbsp; } else if (fractionMatcher.matches()) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; throw new NumberFormatException(&quot;Fractional values are not supported. Input was: &quot;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + fractionMatcher.group(1));<br/>
&nbsp; &nbsp; &nbsp; } else {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; throw new NumberFormatException(&quot;Failed to parse byte string: &quot; + str);<br/>
&nbsp; &nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; } catch (NumberFormatException e) {<br/>
&nbsp; &nbsp; &nbsp; String byteError = &quot;Size must be specified as bytes (b), &quot; +<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;kibibytes (k), mebibytes (m), gibibytes (g), tebibytes (t), or pebibytes(p). &quot; +<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;E.g. 50b, 100k, or 250m.&quot;;<br/>
<br/>
&nbsp; &nbsp; &nbsp; throw new NumberFormatException(byteError + &quot;\n&quot; + e.getMessage());<br/>
&nbsp; &nbsp; }<br/>
&nbsp; }<br/>
}<br/>
</code>

 </body>
</html>
