<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>util/MemoryFormatUtils.java - Spark Insight</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}


  </style>
 </head>
 <body>

  <h1>util/MemoryFormatUtils.java - Spark Insight</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L29">MemoryFormatUtils</a></li>
<li><a href="#L34">MemoryUnit</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L30">MemoryFormatUtils</a></li>
<li><a href="#L38">MemoryUnit</a></li>
<li><a href="#L72">bytesToString</a></li>
<li><a href="#L47">getBytes</a></li>
<li><a href="#L43">getName</a></li>
<li><a href="#L131">roundOffMemoryStringToNextInteger</a></li>
<li><a href="#L93">stringToBytes</a></li>
<li><a href="#L52">toString</a></li>
</ul>
 <h2>Source code</h2>

  <code>/*<br/>
 * Copyright 2016 LinkedIn Corp.<br/>
 *<br/>
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not<br/>
 * use this file except in compliance with the License. You may obtain a copy of<br/>
 * the License at<br/>
 *<br/>
 * http://www.apache.org/licenses/LICENSE-2.0<br/>
 *<br/>
 * Unless required by applicable law or agreed to in writing, software<br/>
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT<br/>
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the<br/>
 * License for the specific language governing permissions and limitations under<br/>
 * the License.<br/>
 */<br/>
<br/>
package com.microsoft.spark.insight.util;<br/>
<br/>
import org.apache.commons.lang.StringUtils;<br/>
<br/>
import java.text.DecimalFormat;<br/>
import java.util.regex.Matcher;<br/>
import java.util.regex.Pattern;<br/>
<br/>
<br/>
/**<br/>
 * This is a utils class that handles memory string parsing and formatting problem.<br/>
 */<br/>
<a id="L29">&#x200c;</a>public class <span class="linkable">MemoryFormatUtils</span> {<br/>
<a id="L30">&#x200c;</a>&nbsp; private <span class="linkable">MemoryFormatUtils</span>() {<br/>
&nbsp; &nbsp; // Do nothing, empty on purpose<br/>
&nbsp; }<br/>
<br/>
<a id="L34">&#x200c;</a>&nbsp; private static class <span class="linkable">MemoryUnit</span> {<br/>
&nbsp; &nbsp; private final String _name;<br/>
&nbsp; &nbsp; private final long _bytes;<br/>
<br/>
<a id="L38">&#x200c;</a>&nbsp; &nbsp; public <span class="linkable">MemoryUnit</span>(String name, long bytes) {<br/>
&nbsp; &nbsp; &nbsp; _name = name;<br/>
&nbsp; &nbsp; &nbsp; _bytes = bytes;<br/>
&nbsp; &nbsp; }<br/>
<br/>
<a id="L43">&#x200c;</a>&nbsp; &nbsp; public String <span class="linkable">getName</span>() {<br/>
&nbsp; &nbsp; &nbsp; return _name;<br/>
&nbsp; &nbsp; }<br/>
<br/>
<a id="L47">&#x200c;</a>&nbsp; &nbsp; public long <span class="linkable">getBytes</span>() {<br/>
&nbsp; &nbsp; &nbsp; return _bytes;<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; @Override<br/>
<a id="L52">&#x200c;</a>&nbsp; &nbsp; public String <span class="linkable">toString</span>() {<br/>
&nbsp; &nbsp; &nbsp; return _name;<br/>
&nbsp; &nbsp; }<br/>
&nbsp; }<br/>
<br/>
&nbsp; // Units must be in a descent order<br/>
&nbsp; private static final <a href="#L34" title="util/MemoryFormatUtils.java:34">MemoryUnit</a>[] UNITS =<br/>
&nbsp; &nbsp; &nbsp; new <a href="#L34" title="util/MemoryFormatUtils.java:34">MemoryUnit</a>[]{new <a href="#L34" title="util/MemoryFormatUtils.java:34">MemoryUnit</a>(&quot;TB&quot;, 1L &lt;&lt; 40), new <a href="#L34" title="util/MemoryFormatUtils.java:34">MemoryUnit</a>(&quot;GB&quot;, 1L &lt;&lt; 30), new <a href="#L34" title="util/MemoryFormatUtils.java:34">MemoryUnit</a>(&quot;MB&quot;,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1L &lt;&lt; 20), new <a href="#L34" title="util/MemoryFormatUtils.java:34">MemoryUnit</a>(&quot;KB&quot;, 1L &lt;&lt; 10), new <a href="#L34" title="util/MemoryFormatUtils.java:34">MemoryUnit</a>(&quot;B&quot;, 1L)};<br/>
<br/>
&nbsp; private static final DecimalFormat FORMATTER = new DecimalFormat(&quot;#,##0.##&quot;);<br/>
&nbsp; private static final Pattern REGEX_MATCHER =<br/>
&nbsp; &nbsp; &nbsp; Pattern.compile(&quot;([-+]?\\d*\\.?\\d+(?:[eE][-+]?\\d+)?)\\s*((?:[T|G|M|K])?B?)?&quot;, Pattern.CASE_INSENSITIVE);<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Given a memory value in bytes, convert it to a string with the unit that round to a &gt;0 integer part.<br/>
&nbsp;&nbsp; *<br/>
&nbsp;&nbsp; * @param value The memory value in long bytes<br/>
&nbsp;&nbsp; * @return The formatted string, null if<br/>
&nbsp;&nbsp; */<br/>
<a id="L72">&#x200c;</a>&nbsp; public static String <span class="linkable">bytesToString</span>(long value) {<br/>
&nbsp; &nbsp; if (value &lt; 0) {<br/>
&nbsp; &nbsp; &nbsp; throw new IllegalArgumentException(&quot;Invalid memory size: &quot; + value);<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; for (int i = 0; i &lt; UNITS.length; i++) {<br/>
&nbsp; &nbsp; &nbsp; long bytes = UNITS[i].<a href="#L47" title="util/MemoryFormatUtils.java:47">getBytes</a>();<br/>
&nbsp; &nbsp; &nbsp; if (value &gt;= bytes) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; double numResult = bytes &gt; 1 ? (double) value / (double) bytes : (double) value;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; return FORMATTER.format(numResult) + &quot; &quot; + UNITS[i].<a href="#L43" title="util/MemoryFormatUtils.java:43">getName</a>();<br/>
&nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; return value + &quot; &quot; + UNITS[UNITS.length - 1].<a href="#L43" title="util/MemoryFormatUtils.java:43">getName</a>();<br/>
&nbsp; }<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Convert a formatted string into a long value in bytes.<br/>
&nbsp;&nbsp; * This method handles<br/>
&nbsp;&nbsp; *<br/>
&nbsp;&nbsp; * @param formattedString The string to convert<br/>
&nbsp;&nbsp; * @return The bytes value<br/>
&nbsp;&nbsp; */<br/>
<a id="L93">&#x200c;</a>&nbsp; public static long <span class="linkable">stringToBytes</span>(String formattedString) {<br/>
&nbsp; &nbsp; if (formattedString == null) {<br/>
&nbsp; &nbsp; &nbsp; return 0L;<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; Matcher matcher = REGEX_MATCHER.matcher(formattedString.replace(&quot;,&quot;,&quot;&quot;));<br/>
&nbsp; &nbsp; if (!matcher.matches()) {<br/>
&nbsp; &nbsp; &nbsp; throw new IllegalArgumentException(<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;The formatted string [&quot; + formattedString + &quot;] does not match with the regex /&quot; + REGEX_MATCHER.<a href="#L52" title="util/MemoryFormatUtils.java:52">toString</a>()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + &quot;/&quot;);<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; if (matcher.groupCount() != 1 &amp;&amp; matcher.groupCount() != 2) {<br/>
&nbsp; &nbsp; &nbsp; throw new IllegalArgumentException();<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; double numPart = Double.parseDouble(matcher.group(1));<br/>
&nbsp; &nbsp; if (numPart &lt; 0) {<br/>
&nbsp; &nbsp; &nbsp; throw new IllegalArgumentException(&quot;The number part of the memory cannot be less than zero: [&quot; + numPart + &quot;].&quot;);<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; String unitPart = matcher.groupCount() == 2 ? matcher.group(2).toUpperCase() : &quot;&quot;;<br/>
&nbsp; &nbsp; if (!unitPart.endsWith(&quot;B&quot;)) {<br/>
&nbsp; &nbsp; &nbsp; unitPart += &quot;B&quot;;<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; for (int i = 0; i &lt; UNITS.length; i++) {<br/>
&nbsp; &nbsp; &nbsp; if (unitPart.equals(UNITS[i].<a href="#L43" title="util/MemoryFormatUtils.java:43">getName</a>())) {<br/>
&nbsp; &nbsp; &nbsp; &nbsp; return (long) (numPart * UNITS[i].<a href="#L47" title="util/MemoryFormatUtils.java:47">getBytes</a>());<br/>
&nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; throw new IllegalArgumentException(&quot;The formatted string [&quot; + formattedString + &quot;] 's unit part [&quot; + unitPart<br/>
&nbsp; &nbsp; &nbsp; &nbsp; + &quot;] does not match any unit. The supported units are (case-insensitive, and also the 'B' is ignorable): [&quot;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; + StringUtils.join(UNITS) + &quot;].&quot;);<br/>
&nbsp; }<br/>
<br/>
&nbsp; /**<br/>
&nbsp;&nbsp; * Given a memory value in string format, it rounds off the double value to next integer.<br/>
&nbsp;&nbsp; * @param formattedString<br/>
&nbsp;&nbsp; * @return : formatted String with int value to next integer.<br/>
&nbsp;&nbsp; */<br/>
<a id="L131">&#x200c;</a>&nbsp; public static String <span class="linkable">roundOffMemoryStringToNextInteger</span>(String formattedString) {<br/>
&nbsp; &nbsp; if (formattedString == null || formattedString.isEmpty()) {<br/>
&nbsp; &nbsp; &nbsp; return &quot;&quot;;<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; //handling if the string has , for eg. 1,000MB<br/>
&nbsp; &nbsp; formattedString = formattedString.replace(&quot;,&quot;, &quot;&quot;);<br/>
<br/>
&nbsp; &nbsp; Matcher matcher = REGEX_MATCHER.matcher(formattedString);<br/>
&nbsp; &nbsp; if (!matcher.matches()) {<br/>
&nbsp; &nbsp; &nbsp; throw new IllegalArgumentException(<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;The formatted string [&quot; + formattedString + &quot;] does not match with the regex /&quot; + REGEX_MATCHER.<a href="#L52" title="util/MemoryFormatUtils.java:52">toString</a>()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + &quot;/&quot;);<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; if (matcher.groupCount() != 1 &amp;&amp; matcher.groupCount() != 2) {<br/>
&nbsp; &nbsp; &nbsp; throw new IllegalArgumentException();<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; double numPart = Double.parseDouble(matcher.group(1));<br/>
&nbsp; &nbsp; if (numPart &lt; 0) {<br/>
&nbsp; &nbsp; &nbsp; throw new IllegalArgumentException(&quot;The number part of the memory cannot be less than zero: [&quot; + numPart + &quot;].&quot;);<br/>
&nbsp; &nbsp; }<br/>
<br/>
&nbsp; &nbsp; int numPartInt = (int) Math.ceil(numPart);<br/>
<br/>
&nbsp; &nbsp; String unitPart = matcher.groupCount() == 2 ? matcher.group(2).toUpperCase() : &quot;&quot;;<br/>
&nbsp; &nbsp; if (!unitPart.endsWith(&quot;B&quot;)) {<br/>
&nbsp; &nbsp; &nbsp; unitPart += &quot;B&quot;;<br/>
&nbsp; &nbsp; }<br/>
&nbsp; &nbsp; return (numPartInt + &quot; &quot; + unitPart);<br/>
&nbsp; }<br/>
}<br/>
</code>

 </body>
</html>
